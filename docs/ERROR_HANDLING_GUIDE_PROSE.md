# 에러 핸들링 가이드 - 상세 설명

## 개요

Good Ruck 애플리케이션은 사용자 경험을 보호하고 시스템 안정성을 보장하기 위해 포괄적인 에러 핸들링 시스템을 구현합니다. 이 시스템은 프론트엔드와 백엔드 모두에서 일관된 에러 처리를 제공하며, 사용자에게 명확한 피드백을 제공하고 개발자에게는 디버깅에 필요한 충분한 정보를 제공합니다.

## 에러 분류 시스템

애플리케이션의 모든 에러는 크게 세 가지 카테고리로 분류됩니다. 첫 번째는 사용자 에러로, HTTP 상태 코드 400번대에 해당하며 사용자의 잘못된 입력이나 권한 문제를 나타냅니다. 두 번째는 시스템 에러로, 500번대 상태 코드를 사용하며 서버 내부의 문제나 외부 서비스 장애를 의미합니다. 세 번째는 GPS 특화 에러로, 위치 기반 기능에서 발생하는 고유한 문제들을 처리합니다.

### 사용자 에러 (4xx)

검증 에러는 사용자가 입력한 데이터가 시스템의 요구사항을 충족하지 못할 때 발생합니다. 예를 들어, 거리 값이 음수이거나 제목이 너무 길 경우 VALIDATION_ERROR 타입의 에러가 반환됩니다. 이러한 에러는 재시도가 불가능하며(retryable: false), 사용자가 입력을 수정해야만 해결됩니다. 각 검증 에러는 구체적인 에러 코드(VALIDATION_001 ~ VALIDATION_010)를 가지며, 어떤 필드에서 어떤 문제가 발생했는지 상세하게 알려줍니다.

인증 에러는 사용자의 신원을 확인할 수 없을 때 발생합니다. 토큰이 제공되지 않았거나(AUTH_001), 토큰이 유효하지 않거나(AUTH_002), 토큰이 만료된 경우(AUTH_003)에 401 Unauthorized 응답이 반환됩니다. 이러한 상황에서 사용자는 다시 로그인해야 하며, 프론트엔드는 자동으로 로그인 페이지로 리다이렉트합니다.

권한 에러는 사용자가 인증되었지만 특정 리소스에 접근할 권한이 없을 때 발생합니다. 예를 들어, 다른 사용자의 운동 기록을 삭제하려고 시도하면 AUTHZ_002 에러와 함께 403 Forbidden 응답이 반환됩니다. 이는 보안을 위해 매우 중요한 체크포인트입니다.

리소스를 찾을 수 없는 경우 404 Not Found 에러가 발생합니다. 존재하지 않는 운동 ID를 조회하거나, 삭제된 데이터에 접근하려고 할 때 NOT_FOUND_001 ~ NOT_FOUND_003 에러 코드가 사용됩니다.

### 시스템 에러 (5xx)

내부 서버 에러는 예상하지 못한 서버 문제가 발생했을 때 반환됩니다. 이러한 에러는 대부분 재시도 가능(retryable: true)하며, 시스템이 일시적인 과부하 상태이거나 외부 의존성에 문제가 있을 때 발생합니다. INTERNAL_001 에러는 가장 일반적인 서버 에러이며, 개발 환경에서는 상세한 스택 트레이스를 제공하지만 프로덕션에서는 보안을 위해 일반적인 메시지만 반환됩니다.

데이터베이스 에러는 SQLite 데이터베이스와의 통신에 문제가 있을 때 발생합니다. 연결 실패(DB_002), 쿼리 실패(DB_001) 등이 이에 해당하며, 모두 500 상태 코드와 함께 재시도 가능한 에러로 분류됩니다. 이러한 에러가 발생하면 자동으로 로깅 시스템에 기록되어 관리자가 신속하게 대응할 수 있습니다.

서비스 사용 불가 에러는 시스템이 일시적으로 과부하 상태이거나 유지보수 중일 때 반환됩니다. 503 Service Unavailable 상태 코드와 함께 SERVICE_001 에러 코드가 사용되며, 클라이언트는 지수 백오프 알고리즘을 사용하여 재시도합니다.

### GPS 특화 에러

GPS 권한 거부 에러는 사용자가 위치 권한을 명시적으로 거부했을 때 발생합니다. GPS_001 에러 코드와 함께 "GPS 권한이 거부되었습니다. 설정에서 위치 권한을 허용해주세요"라는 한국어 메시지가 표시됩니다. 이 에러는 재시도 불가능(retryable: false)하며, 사용자가 디바이스 설정에서 권한을 변경해야만 해결됩니다. 프론트엔드는 권한 설정 방법을 안내하는 전용 화면을 표시합니다.

GPS 사용 불가 에러는 디바이스가 현재 위치를 파악할 수 없는 상황에서 발생합니다. 실내에 있거나 GPS 신호가 차단된 환경에서 주로 발생하며, GPS_002 에러 코드가 사용됩니다. 이 에러는 재시도 가능하므로, 사용자에게 실외로 이동하거나 잠시 후 다시 시도할 것을 권장합니다.

GPS 타임아웃 에러는 일정 시간 내에 GPS 신호를 획득하지 못했을 때 발생합니다. 초기 위치 획득에는 10초, 업데이트에는 5초의 타임아웃이 설정되어 있습니다. GPS_003 에러가 발생하면 시스템은 자동으로 저정확도 모드로 전환을 시도합니다.

GPS 정확도 낮음 에러는 위치 정보를 획득했지만 정확도가 허용 범위를 벗어났을 때 발생합니다. 50미터 이상의 오차가 있을 경우 GPS_004 에러가 발생하며, 사용자에게 현재 정확도 수치와 함께 개선 방법을 안내합니다.

## 프론트엔드 에러 핸들링

### 에러 타입과 인터페이스

프론트엔드는 TypeScript를 사용하여 모든 에러를 강타입으로 정의합니다. ErrorType enum은 16가지 에러 유형을 정의하고, ErrorCode enum은 46개의 세부 에러 코드를 포함합니다. AppError 인터페이스는 에러의 모든 속성을 표준화하여 일관된 처리를 가능하게 합니다.

각 AppError 객체는 type(에러 유형), code(세부 코드), message(사용자 메시지), details(검증 에러의 경우 필드별 상세 정보), statusCode(HTTP 상태 코드), retryable(재시도 가능 여부), timestamp(발생 시각) 속성을 포함합니다. 이러한 표준화된 구조 덕분에 모든 에러를 동일한 방식으로 처리하고 표시할 수 있습니다.

### API 에러 처리

handleApiError 함수는 모든 API 호출에서 발생하는 에러를 처리하는 중앙 허브입니다. fetch API나 axios에서 발생한 에러를 받아서 AppError 형식으로 변환합니다. 네트워크 연결이 불가능한 경우(error.response가 없는 경우)에는 NETWORK_ERROR 타입의 에러를 생성하고 재시도 가능으로 표시합니다.

서버로부터 응답을 받은 경우에는 HTTP 상태 코드를 분석하여 적절한 에러 타입을 결정합니다. 400번대 에러는 클라이언트 문제이므로 재시도 불가능으로, 500번대 에러는 서버 문제이므로 재시도 가능으로 분류됩니다. 서버가 제공한 에러 코드와 메시지가 있으면 그대로 사용하고, 없으면 미리 정의된 기본 메시지를 사용합니다.

### 재시도 로직

withRetry 함수는 실패한 API 호출을 자동으로 재시도하는 고급 래퍼입니다. 기본적으로 최대 3번까지 재시도하며, 각 재시도 사이에는 지수 백오프 알고리즘을 적용합니다. 첫 번째 재시도는 1초 후, 두 번째는 2초 후, 세 번째는 4초 후에 실행되며, 최대 지연 시간은 10초로 제한됩니다.

재시도는 retryable 속성이 true인 경우에만 실행됩니다. 검증 에러나 권한 에러처럼 재시도해도 결과가 달라지지 않는 경우에는 즉시 에러를 발생시킵니다. 각 재시도 시도마다 onRetry 콜백을 호출하여 UI에 재시도 상태를 표시할 수 있습니다.

랜덤 지터(jitter)를 추가하여 여러 클라이언트가 동시에 재시도하는 것을 방지합니다. 각 지연 시간에 0~1초의 무작위 시간을 더해 서버의 부하를 분산시킵니다.

### 폼 에러 처리

createFormErrorState 함수는 API 에러를 React Hook Form에서 사용할 수 있는 형식으로 변환합니다. 검증 에러의 경우 details 배열에서 각 필드의 에러 메시지를 추출하여 fieldErrors 객체를 생성합니다. 예를 들어, distance 필드에 에러가 있으면 `{ distance: "거리는 최소 0.01km 이상이어야 합니다" }` 형태로 변환됩니다.

FormErrorState 인터페이스는 전체 폼 수준의 에러 메시지와 필드별 에러 메시지를 모두 포함합니다. 이를 통해 폼 상단에 전반적인 에러 메시지를 표시하면서, 각 입력 필드에는 해당 필드의 구체적인 에러를 표시할 수 있습니다.

### GPS 에러 처리

handleGPSError 함수는 Geolocation API의 에러를 처리합니다. GeolocationPositionError 객체의 code 속성을 확인하여 적절한 AppError를 생성합니다. PERMISSION_DENIED(코드 1)는 GPS_001 에러로, POSITION_UNAVAILABLE(코드 2)는 GPS_002로, TIMEOUT(코드 3)는 GPS_003으로 매핑됩니다.

createGPSAccuracyError 함수는 위치를 획득했지만 정확도가 낮은 경우의 에러를 생성합니다. 현재 정확도 수치를 메시지에 포함시켜 "GPS 정확도가 너무 낮습니다. 신호를 개선하고 다시 시도해주세요 (현재: ±85m)"와 같이 구체적인 피드백을 제공합니다.

## 백엔드 에러 핸들링

### 에러 클래스 계층

백엔드는 커스텀 AppError 클래스를 기본으로 하는 에러 계층 구조를 사용합니다. AppError 클래스는 JavaScript의 기본 Error 클래스를 상속하며, 에러 코드, HTTP 상태 코드, 재시도 가능 여부, 타임스탬프 등의 추가 정보를 포함합니다.

ERROR_CODES 객체는 46개의 에러 코드와 각각의 상태 코드, 기본 메시지를 정의합니다. 예를 들어 VALIDATION_001은 상태 코드 400과 "Invalid input" 메시지를 가집니다. 이 중앙화된 정의 덕분에 에러 코드만으로 모든 필요한 정보를 조회할 수 있습니다.

특화된 에러 클래스들은 AppError를 상속하여 편의성을 제공합니다. ValidationError는 필드 이름과 메시지를 받아 자동으로 VALIDATION_001 코드를 할당합니다. AuthenticationError, AuthorizationError, NotFoundError, DatabaseError도 마찬가지로 해당 도메인의 기본 설정을 제공합니다.

### 에러 핸들러 미들웨어

errorHandler 미들웨어는 Express 애플리케이션의 마지막에 등록되어 모든 에러를 처리합니다. 응답이 이미 전송된 경우(res.headersSent)에는 Express의 기본 에러 핸들러에게 위임하여 메모리 누수를 방지합니다.

AppError 인스턴스는 이미 구조화된 정보를 가지고 있으므로, statusCode와 에러 정보를 그대로 JSON 응답으로 변환합니다. 일반 Error 인스턴스의 경우에는 에러의 이름을 확인하여 특수한 처리를 합니다. JsonWebTokenError는 인증 에러로, TokenExpiredError는 토큰 만료로, JSON SyntaxError는 검증 에러로 변환됩니다.

모든 에러는 logError 함수를 통해 로깅됩니다. 로그에는 타임스탬프, 에러 타입, 코드, 메시지, 상태 코드, 요청 경로, HTTP 메서드, 요청 ID, 사용자 ID, IP 주소(마스킹됨), User-Agent 등이 포함됩니다. 개발 환경에서는 스택 트레이스도 포함하여 디버깅을 용이하게 합니다.

### 민감 데이터 마스킹

maskSensitiveData 함수는 로그에 기록되기 전에 민감한 정보를 제거하거나 마스킹합니다. password, password_hash, token, refreshToken 필드는 완전히 삭제됩니다. 이메일 주소는 로컬 부분의 처음 2글자와 마지막 1글자만 남기고 나머지를 별표로 대체합니다(예: "us***r@example.com").

GPS 경로 데이터는 개인의 이동 패턴을 추적할 수 있으므로 매우 민감합니다. route 배열의 실제 좌표 대신 "[523 GPS points]"와 같이 포인트 개수만 로깅합니다. 개별 좌표의 경우에도 정수 부분만 남기고 소수점 이하를 제거하여 대략적인 지역만 파악 가능하게 합니다.

IP 주소는 마지막 옥텟을 "xxx"로 대체하여 서브넷 수준까지만 식별 가능하게 합니다(예: "192.168.1.xxx"). 이는 일반적인 문제 진단에는 충분하면서도 개인을 특정할 수 없도록 합니다.

### asyncHandler 래퍼

asyncHandler 함수는 비동기 라우트 핸들러를 감싸서 발생하는 모든 에러를 자동으로 next()로 전달합니다. 이를 통해 각 라우트에서 try-catch 블록을 작성할 필요가 없어집니다.

```javascript
// asyncHandler 없이
app.get('/workouts', async (req, res, next) => {
  try {
    const workouts = await getWorkouts();
    res.json(workouts);
  } catch (error) {
    next(error);
  }
});

// asyncHandler 사용
app.get('/workouts', asyncHandler(async (req, res) => {
  const workouts = await getWorkouts();
  res.json(workouts);
}));
```

### 환경별 에러 메시지

getUserMessage 함수는 환경에 따라 다른 수준의 에러 정보를 제공합니다. 개발 환경(NODE_ENV=development)에서는 실제 에러 메시지를 그대로 반환하여 디버깅을 돕습니다. 프로덕션 환경에서는 보안을 위해 일반화된 메시지만 반환합니다.

예를 들어, 데이터베이스 연결 문자열이 에러 메시지에 노출되는 것을 방지하기 위해 "Database connection failed: sqlite://path/to/db" 대신 "Database error occurred"만 반환합니다. 이는 잠재적인 보안 취약점을 방지하는 중요한 방어 계층입니다.

## 사용자 인터페이스

### ErrorBoundary 컴포넌트

ErrorBoundary는 React 컴포넌트 트리에서 발생하는 예상치 못한 렌더링 에러를 포착합니다. getDerivedStateFromError 메서드를 통해 에러 상태를 업데이트하고, componentDidCatch에서 에러를 로깅합니다.

에러가 발생하면 전체 애플리케이션이 멈추는 대신 fallback UI를 표시합니다. 기본 fallback은 검은 배경에 경고 아이콘과 함께 "문제가 발생했습니다"라는 제목과 "앱 실행 중 오류가 발생했습니다. 페이지를 새로고침해주세요"라는 설명을 보여줍니다.

두 개의 버튼을 제공합니다. "새로고침" 버튼은 window.location.reload()를 호출하여 페이지 전체를 새로 불러옵니다. "다시 시도" 버튼은 에러 상태만 초기화하여 컴포넌트를 다시 렌더링합니다. 개발 환경에서는 접을 수 있는 에러 상세 정보 섹션이 추가로 표시됩니다.

### ErrorMessage 컴포넌트

ErrorMessage는 특정 에러를 사용자에게 시각적으로 표시하는 재사용 가능한 컴포넌트입니다. 에러 타입에 따라 다른 아이콘과 색상을 사용합니다. 검증 에러는 노란색 배경에 "!" 아이콘을, 네트워크 에러는 빨간색 배경에 "NET" 텍스트를 표시합니다.

에러 메시지는 세 가지 수준으로 구성됩니다. 제목은 에러의 카테고리를 나타냅니다(예: "입력 오류", "네트워크 오류"). 본문은 구체적인 문제와 해결 방법을 설명합니다. 재시도 가능한 에러의 경우 "다시 시도" 버튼이 자동으로 표시됩니다.

onRetry와 onDismiss 콜백을 통해 유연한 상호작용을 제공합니다. 재시도 가능한 에러는 "다시 시도"와 "닫기" 버튼을 모두 표시하고, 재시도 불가능한 에러는 우측 상단에 X 버튼만 표시합니다.

### GPS 권한 거부 화면

GPSPermissionDenied 컴포넌트는 사용자가 GPS 권한을 거부했을 때 전용 전체 화면을 표시합니다. 중앙에 큰 🚫 아이콘과 함께 "GPS 권한이 필요합니다"라는 명확한 제목을 보여줍니다.

"권한 허용하기" 버튼은 권한 요청을 재시도합니다. 브라우저나 운영체제의 권한 대화상자가 다시 표시되며, 사용자가 허용하면 즉시 GPS 기능이 활성화됩니다.

"권한 설정 방법" 버튼을 누르면 플랫폼별 상세 가이드가 펼쳐집니다. Chrome (Android)의 경우 "설정 > 개인정보 보호 및 보안 > 사이트 설정 > 위치" 경로를 단계별로 안내합니다. Safari (iOS)의 경우 "설정 > Safari > 위치 > 사용 중 허용" 경로를 제공합니다. 이러한 구체적인 안내를 통해 사용자가 쉽게 권한을 재설정할 수 있습니다.

### GPS 상태 표시

GPSStatus 컴포넌트는 실시간 GPS 상태를 시각적으로 표현합니다. GPS 신호를 검색 중일 때는 노란색 배경에 깜빡이는 안테나 아이콘과 "GPS 신호 검색 중..." 메시지를 표시합니다.

위치를 획득한 후에는 정확도에 따라 다른 색상과 아이콘을 사용합니다. 우수(0-10m)는 녹색 원, 좋음(10-30m)은 파란색 원, 보통(30-50m)은 노란색 원, 낮음(50-100m)은 주황색 원, 매우 낮음(100m+)은 빨간색 원을 표시합니다.

정확도 수치는 "정확도: ±25m"와 같은 형식으로 표시되어 사용자가 현재 GPS 품질을 직관적으로 이해할 수 있습니다. 정확도가 낮거나 매우 낮은 경우에는 추가 안내 메시지를 표시합니다: "실외로 이동하거나 Wi-Fi를 켜면 정확도가 향상됩니다."

추적 중일 때는 아이콘이 부드럽게 깜빡여 활성 상태를 나타내고, 우측에 "추적 중" 텍스트가 표시됩니다.

## 에러 메시지 표준

### 한국어 메시지 가이드

모든 사용자 대면 에러 메시지는 한국어로 작성됩니다. 메시지는 명확하고 구체적이어야 하며, 가능한 경우 해결 방법을 포함해야 합니다.

좋은 메시지의 예: "GPS 권한이 거부되었습니다. 설정에서 위치 권한을 허용해주세요." 이 메시지는 무엇이 문제인지(권한 거부), 어떻게 해결할 수 있는지(설정에서 허용) 모두 명확하게 전달합니다.

나쁜 메시지의 예: "에러가 발생했습니다." 이는 너무 모호하여 사용자가 무엇을 해야 할지 알 수 없습니다.

필드별 에러 메시지는 FIELD_ERROR_MESSAGES 객체에 정의되어 있습니다. distance 필드의 min 에러는 "거리는 최소 0.01km 이상이어야 합니다"로, duration 필드의 max 에러는 "시간은 최대 1440분(24시간)을 초과할 수 없습니다"로 표현됩니다.

### 에러 코드 네이밍 규칙

에러 코드는 일관된 패턴을 따릅니다. 첫 부분은 카테고리를 나타냅니다: VALIDATION, AUTH, AUTHZ, NOT_FOUND, GPS, NETWORK 등. 언더스코어 뒤의 숫자는 해당 카테고리 내에서의 순차 번호입니다.

VALIDATION_001 ~ VALIDATION_010은 각기 다른 검증 실패 원인을 나타냅니다. _001은 일반적인 입력 오류, _002는 필수 필드 누락, _003은 최소값 미달, _004는 최대값 초과, _006은 GPS 좌표 오류 등 의미가 명확합니다.

GPS 관련 에러는 GPS_001 ~ GPS_004로 권한 거부, 사용 불가, 타임아웃, 낮은 정확도를 각각 나타냅니다. 이러한 일관성 덕분에 코드만 봐도 어떤 문제인지 즉시 파악할 수 있습니다.

## 실전 시나리오

### 시나리오 1: 네트워크 장애 시 운동 저장

사용자가 운동을 완료하고 저장 버튼을 눌렀지만 네트워크 연결이 끊어진 상황입니다. withRetry 함수가 자동으로 활성화되어 1초 후 첫 번째 재시도를 시도합니다. 여전히 실패하면 2초 후 두 번째 재시도, 4초 후 세 번째 재시도를 수행합니다.

UI에는 "저장 중..." 표시가 유지되며, 각 재시도마다 "연결 재시도 중 (1/3)" 같은 피드백을 제공할 수 있습니다. 3번의 재시도 후에도 실패하면 NETWORK_001 에러가 발생하고, ErrorMessage 컴포넌트가 "네트워크 연결을 확인해주세요"라는 메시지와 함께 "다시 시도" 버튼을 표시합니다.

미래 개선사항으로 오프라인 저장 기능을 구현할 수 있습니다. IndexedDB에 운동 데이터를 저장하고, 네트워크가 복구되면 자동으로 서버에 동기화합니다.

### 시나리오 2: 잘못된 입력값 제출

사용자가 수동으로 운동을 입력하면서 거리를 -5km, 시간을 0분으로 입력하고 저장을 시도합니다. 클라이언트 측 Zod 스키마가 먼저 검증을 수행하여 "거리는 최소 0.01km 이상이어야 합니다"와 "시간은 최소 0.1분 이상이어야 합니다"라는 에러 메시지를 각 필드 아래에 빨간색으로 표시합니다.

사용자가 클라이언트 측 검증을 우회하더라도(예: 개발자 도구를 사용하여), 서버 측 검증이 두 번째 방어선 역할을 합니다. 서버는 VALIDATION_ERROR 타입과 VALIDATION_003, VALIDATION_002 코드를 포함한 응답을 반환하며, details 배열에 각 필드의 문제를 상세히 기록합니다.

프론트엔드는 이 응답을 parseValidationErrors를 통해 처리하여 동일한 필드별 에러 메시지를 표시합니다. 이러한 이중 검증 전략은 사용자 경험을 해치지 않으면서도 보안을 보장합니다.

### 시나리오 3: GPS 정확도 문제

사용자가 건물 내에서 GPS 운동 추적을 시작합니다. 초기에는 GPSStatus 컴포넌트가 "GPS 신호 검색 중..." 상태를 표시합니다. 10초의 타임아웃 후에도 신호를 획득하지 못하면 GPS_003 타임아웃 에러가 발생합니다.

시스템은 자동으로 저정확도 모드(enableHighAccuracy: false)로 전환하여 재시도합니다. 이번에는 Wi-Fi 기반 위치를 사용하여 성공하지만 정확도가 85미터입니다. 이는 허용 범위(50미터)를 초과하므로 GPS_004 에러가 발생합니다.

GPSStatus 컴포넌트는 빨간색 원과 함께 "GPS 상태: 매우 낮음, 정확도: ±85m"를 표시하고, 하단에 "실외로 이동하거나 Wi-Fi를 켜면 정확도가 향상됩니다"라는 안내를 제공합니다. 사용자가 실외로 이동하면 정확도가 15미터로 개선되고, 녹색 "우수" 상태로 전환되어 정상적인 추적이 시작됩니다.

### 시나리오 4: 권한 없는 리소스 접근

사용자 A가 사용자 B의 운동 기록을 삭제하려고 시도합니다. 프론트엔드는 DELETE 요청을 서버에 전송하고, authenticateToken 미들웨어가 먼저 JWT를 검증하여 사용자 ID를 추출합니다.

authorizeOwnership 미들웨어가 데이터베이스에서 해당 운동의 소유자를 조회합니다. user_id가 일치하지 않으므로 AUTHZ_002 에러를 발생시키며, "이 리소스는 소유자만 접근할 수 있습니다"라는 메시지와 함께 403 Forbidden 응답을 반환합니다.

프론트엔드는 이를 AUTHORIZATION_ERROR로 처리하여 "접근 권한이 없습니다"라는 메시지를 표시합니다. 재시도 불가능한 에러이므로 "다시 시도" 버튼은 표시되지 않으며, 사용자는 자신의 운동 목록으로 돌아갑니다.

## 모니터링과 로깅

### 로그 구조

모든 에러 로그는 JSON 형식으로 구조화되어 있어 자동화된 분석이 가능합니다. 각 로그 항목은 timestamp(ISO 8601 형식), level(ERROR 또는 WARN), type(에러 클래스 이름), code(에러 코드), message(메시지), statusCode, path(요청 경로), method(HTTP 메서드), requestId(고유 요청 ID), userId(인증된 경우), ip(마스킹된 IP), userAgent를 포함합니다.

500번대 에러는 ERROR 레벨로, 400번대 에러는 WARN 레벨로 로깅됩니다. 이를 통해 로그 집계 시스템에서 심각도별로 필터링하고 알림을 설정할 수 있습니다. 예를 들어 ERROR 레벨 로그가 1분에 10개 이상 발생하면 관리자에게 알림을 전송할 수 있습니다.

### 에러 추적 통합

프로덕션 환경에서는 Sentry, Datadog, New Relic 같은 에러 추적 서비스와 통합이 권장됩니다. logError 함수에 다음과 같은 코드를 추가할 수 있습니다:

```javascript
if (process.env.SENTRY_DSN && error.statusCode >= 500) {
  Sentry.captureException(error, {
    level: 'error',
    extra: logEntry,
    tags: {
      errorCode: error.code,
      statusCode: error.statusCode
    }
  });
}
```

이를 통해 서버 에러가 발생할 때마다 자동으로 Sentry에 보고되며, 에러 코드별 발생 빈도, 영향받은 사용자 수, 스택 트레이스 등을 시각화하고 추적할 수 있습니다.

### 메트릭 수집

에러 발생률, 재시도 성공률, 평균 응답 시간 등의 메트릭을 수집하여 시스템 건강도를 모니터링합니다. 예를 들어:

- GPS_TIMEOUT 에러가 평소보다 5배 증가하면 GPS 서비스에 문제가 있을 수 있습니다
- NETWORK_ERROR가 특정 지역에서 집중적으로 발생하면 CDN 문제일 수 있습니다
- 재시도 성공률이 낮아지면 백엔드 서비스의 불안정성을 나타냅니다

이러한 메트릭을 대시보드에 표시하고 임계값을 설정하여 문제를 조기에 발견하고 대응할 수 있습니다.

## 모범 사례

### 항상 에러를 처리하라

비동기 작업을 수행하는 모든 코드는 반드시 에러 처리를 포함해야 합니다. Promise를 사용하는 경우 .catch()를, async/await를 사용하는 경우 try-catch를 반드시 사용합니다. 처리되지 않은 Promise rejection은 애플리케이션을 불안정하게 만듭니다.

나쁜 예:
```typescript
const data = await fetchWorkouts();
```

좋은 예:
```typescript
try {
  const data = await fetchWorkouts();
} catch (error) {
  const appError = handleApiError(error);
  showErrorMessage(appError);
}
```

### 재시도 가능 여부를 명확히 하라

에러를 생성할 때 retryable 속성을 정확하게 설정합니다. 사용자의 입력이나 권한 문제는 재시도해도 결과가 같으므로 false로 설정합니다. 네트워크 문제나 서버 과부하는 시간이 지나면 해결될 수 있으므로 true로 설정합니다.

이를 통해 withRetry 함수가 적절하게 동작하고, UI가 "다시 시도" 버튼을 선택적으로 표시할 수 있습니다.

### 사용자에게 명확한 피드백을 제공하라

에러 메시지는 단순히 "에러 발생"이 아니라 무엇이 잘못되었고 어떻게 해결할 수 있는지 설명해야 합니다. 기술 용어를 피하고 일반 사용자가 이해할 수 있는 언어를 사용합니다.

기술적: "GPS GeolocationPositionError code 1"
사용자 친화적: "GPS 권한이 거부되었습니다. 설정에서 위치 권한을 허용해주세요"

### 민감한 정보를 노출하지 마라

에러 메시지나 로그에 비밀번호, 토큰, 상세한 GPS 좌표, 이메일 주소, IP 주소 같은 민감한 정보가 포함되지 않도록 주의합니다. 프로덕션 환경에서는 maskSensitiveData 함수를 거친 데이터만 로깅합니다.

데이터베이스 연결 문자열, API 키, 내부 파일 경로 같은 시스템 정보도 노출하지 않습니다. 이러한 정보는 공격자에게 유용할 수 있습니다.

### 환경별로 다른 처리를 하라

개발 환경에서는 상세한 에러 정보와 스택 트레이스를 제공하여 디버깅을 돕습니다. 프로덕션 환경에서는 보안을 위해 일반화된 메시지만 제공하고, 상세 정보는 서버 로그에만 기록합니다.

NODE_ENV 환경 변수를 확인하여 분기 처리합니다:

```javascript
if (process.env.NODE_ENV === 'development') {
  // 상세 정보 제공
  errorResponse.stack = err.stack;
  errorResponse.details = err.details;
} else {
  // 일반화된 메시지만 제공
  errorResponse.message = getUserMessage(err);
}
```

## 결론

포괄적인 에러 핸들링 시스템은 안정적이고 사용자 친화적인 애플리케이션의 핵심입니다. Good Ruck 애플리케이션은 타입 안전성, 일관된 에러 구조, 자동 재시도, 명확한 사용자 피드백, 철저한 로깅, 민감 데이터 보호를 통해 프로덕션급 에러 처리를 구현합니다.

이 시스템은 사용자가 문제를 쉽게 이해하고 해결할 수 있도록 돕는 동시에, 개발자가 신속하게 문제를 진단하고 수정할 수 있는 정보를 제공합니다. 모든 에러는 적절하게 분류되고, 로깅되고, 처리되어 애플리케이션이 예상치 못한 상황에서도 우아하게 동작합니다.
