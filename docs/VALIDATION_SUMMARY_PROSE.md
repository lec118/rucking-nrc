# 검증 스키마 및 규칙 요약 (설명문)

빠른 이해를 위한 검증 시스템 설명

---

## 개요

Good Ruck 애플리케이션은 사용자가 입력하는 모든 운동 데이터를 철저하게 검증합니다. 검증은 프론트엔드와 백엔드 양쪽에서 이중으로 수행되며, 사용자 경험과 보안을 동시에 보장합니다.

---

## 검증 대상 필드

애플리케이션에서 검증하는 주요 필드는 총 7개입니다.

### 제목 (Title)

운동 제목은 선택 사항이지만, 입력할 경우 1자 이상 100자 이하여야 합니다. 시스템은 자동으로 앞뒤 공백을 제거하고, HTML 태그를 삭제하여 XSS 공격을 방지합니다. 제목을 입력하지 않으면 "Manual Workout"이 기본값으로 설정됩니다. 꺾쇠 괄호(`<`, `>`)는 보안상의 이유로 사용할 수 없습니다.

### 거리 (Distance)

거리는 필수 입력 항목으로, 최소 0.01km(10미터)부터 최대 1,000km까지 입력할 수 있습니다. 소수점은 최대 2자리까지만 허용되므로, 예를 들어 5.12km는 가능하지만 5.123km는 입력할 수 없습니다. 음수나 0은 입력할 수 없으며, 현실적으로 가능한 달리기 거리 범위 내에서만 허용됩니다.

### 시간 (Duration)

운동 시간 역시 필수 항목으로, 최소 0.1분(6초)부터 최대 1,440분(24시간)까지 입력 가능합니다. 거리와 마찬가지로 음수나 0은 허용되지 않으며, 소수점은 1자리까지만 입력할 수 있습니다. 예를 들어 30.5분은 가능하지만 30.25분은 입력할 수 없습니다.

### 페이스 (Pace)

페이스는 1km를 달리는 데 걸린 시간을 분 단위로 나타낸 값으로, 선택 사항입니다. 입력하지 않으면 시스템이 자동으로 시간을 거리로 나누어 계산합니다. 입력할 경우 1분/km부터 60분/km 사이의 값이어야 하며, 이는 현실적으로 가능한 달리기 속도 범위를 의미합니다. 또한 입력한 페이스 값은 거리와 시간으로 계산한 값과 0.5분/km 이내의 오차 범위에 있어야 합니다. 예를 들어 5km를 30분에 달렸다면 페이스는 6분/km이며, 입력값이 5.5~6.5분/km 범위를 벗어나면 거부됩니다.

### 무게 (Weight)

러킹 시 사용한 배낭 무게는 선택 항목으로, 0kg부터 200kg까지 입력할 수 있습니다. 소수점은 1자리까지 허용되므로 10.5kg은 가능하지만 10.25kg은 입력할 수 없습니다. 음수는 허용되지 않으며, 입력하지 않으면 null로 저장됩니다.

### 날짜 (Date)

운동 날짜는 선택 사항이며, ISO 8601 형식(예: "2024-01-15T10:30:00.000Z")으로 입력해야 합니다. 입력하지 않으면 현재 시각이 자동으로 설정됩니다. 날짜는 2020년 1월 1일 이후부터 내일까지만 입력할 수 있습니다. 즉, 너무 오래된 날짜나 미래 날짜는 입력할 수 없지만, 밤늦게 운동하고 다음 날 새벽에 기록하는 경우를 고려하여 내일까지는 허용됩니다.

### 경로 (Route)

GPS로 추적한 운동 경로는 선택 항목으로, 최소 2개 이상의 GPS 좌표를 포함해야 하며 최대 10,000개까지 저장할 수 있습니다. 각 좌표는 위도(-90° ~ 90°)와 경도(-180° ~ 180°) 형식의 배열로 구성됩니다. 시스템은 연속된 두 좌표 사이의 거리를 계산하여 1도(약 111km) 이상의 급격한 점프가 있으면 GPS 오류로 판단하고 거부합니다. 또한 계산된 이동 속도가 시속 30km를 초과하면 비현실적인 것으로 간주하여 해당 좌표를 필터링합니다.

---

## 쿼리 파라미터

운동 목록을 조회할 때 사용하는 쿼리 파라미터는 4개입니다.

### Limit

한 번에 가져올 운동 기록 개수를 지정하며, 1개부터 100개까지 설정할 수 있습니다. 기본값은 50개이므로, 파라미터를 생략하면 최신 50개의 운동 기록을 반환합니다. 서버 부하를 방지하기 위해 100개를 초과하는 요청은 거부됩니다.

### Offset

목록에서 건너뛸 레코드 개수를 지정하며, 페이지네이션에 사용됩니다. 0 이상의 정수여야 하며, 기본값은 0입니다. 예를 들어 offset=50, limit=50으로 요청하면 51번째부터 100번째까지의 운동 기록을 가져옵니다.

### StartDate와 EndDate

특정 기간의 운동 기록을 조회할 때 사용하며, 둘 다 선택 사항입니다. ISO 8601 형식으로 입력해야 하며, startDate가 endDate보다 늦은 날짜이면 검증 오류가 발생합니다. 예를 들어 2024년 1월의 운동 기록만 보려면 startDate="2024-01-01T00:00:00Z", endDate="2024-01-31T23:59:59Z"로 요청합니다.

---

## 교차 검증 규칙

단일 필드 검증 외에도 여러 필드 간의 관계를 확인하는 교차 검증이 수행됩니다.

### 페이스 일관성 검증

사용자가 직접 페이스 값을 입력하는 경우, 이 값이 거리와 시간으로 계산한 페이스와 일치하는지 확인합니다. 구체적으로, 입력한 페이스와 계산된 페이스(시간/거리)의 차이가 0.5분/km 이내여야 합니다. 이는 사용자가 실수로 잘못된 값을 입력하거나, 악의적으로 데이터를 조작하는 것을 방지합니다. 예를 들어 10km를 60분에 달렸다면 페이스는 6분/km이므로, 입력값이 5.5~6.5분/km 범위 밖이면 "거리와 시간이 일치하지 않습니다"라는 오류가 표시됩니다.

### 날짜 범위 검증

운동 목록 조회 시 startDate와 endDate를 모두 입력한 경우, startDate가 endDate보다 앞서거나 같아야 합니다. 시작 날짜가 종료 날짜보다 늦으면 "날짜 범위가 유효하지 않습니다"라는 오류가 발생합니다. 이는 논리적으로 불가능한 조회를 방지합니다.

### 현실성 검증

거리와 시간으로 계산한 페이스가 1분/km부터 60분/km 사이여야 합니다. 1분/km보다 빠르면 인간의 능력을 초과하는 속도이고, 60분/km보다 느리면 걷는 것보다도 느린 속도이므로 비현실적인 것으로 판단합니다. 이러한 값은 "페이스 값이 비현실적입니다"라는 오류 메시지와 함께 거부되며, 사용자가 단위를 잘못 입력했거나 데이터 조작을 시도하는 것을 방지합니다.

---

## GPS 특수 검증

GPS로 추적한 경로 데이터는 추가적인 검증을 거칩니다.

### 좌표 유효성 검증

각 GPS 좌표는 위도와 경도로 구성되며, 위도는 -90도에서 90도 사이, 경도는 -180도에서 180도 사이여야 합니다. 이 범위를 벗어나는 값이나 NaN(Not a Number) 값은 "GPS 좌표가 유효하지 않습니다"라는 오류와 함께 거부됩니다. 이는 GPS 센서 오류나 데이터 전송 중 손상을 감지하는 역할을 합니다.

### 경로 점프 검증

연속된 두 GPS 좌표 사이의 거리가 약 111km(1도)를 초과하면 GPS 신호가 튀었거나 오류가 발생한 것으로 판단합니다. 실제 달리기나 걷기로는 순간적으로 이런 거리를 이동할 수 없기 때문입니다. 이러한 비정상적인 점프가 감지되면 해당 좌표는 자동으로 필터링되거나, 경로 전체가 거부될 수 있습니다.

### 속도 검증

두 GPS 좌표 사이의 이동 거리와 시간 차이를 이용해 속도를 계산합니다. 계산된 속도가 시속 30km를 초과하면 GPS 오류로 판단하고 해당 위치 데이터를 거부합니다. 인간이 달릴 수 있는 최고 속도는 시속 약 44km이지만, 일반적인 러닝에서는 시속 30km를 초과하기 어렵기 때문에 이를 임계값으로 설정했습니다. 이 검증은 GPS 신호가 건물에 반사되거나 실내에서 튀는 멀티패스 오류를 방지합니다.

### 경로 크기 제한

경로는 최소 2개의 좌표(시작점과 끝점)가 필요하며, 최대 10,000개까지 저장할 수 있습니다. 10,000개를 초과하면 "경로 데이터가 너무 큽니다"라는 오류가 발생합니다. 이는 서버 저장 공간과 클라이언트 메모리를 보호하기 위한 조치입니다. 1초마다 하나의 좌표를 기록한다고 가정하면 10,000개는 약 2시간 47분에 해당하므로, 대부분의 운동에는 충분한 용량입니다.

---

## 에러 코드 체계

검증 실패 시 발생하는 에러는 체계적으로 분류되며, 각각 고유한 코드와 사용자 친화적인 메시지를 가집니다.

### VALIDATION_001: 잘못된 입력

입력값의 타입이 예상과 다를 때 발생합니다. 예를 들어 거리 필드에 숫자 대신 문자열 "abc"를 입력하면 이 오류가 발생하며, "입력값이 올바르지 않습니다"라는 메시지가 표시됩니다. 이는 가장 기본적인 타입 검증 오류입니다.

### VALIDATION_002: 필수 필드 누락

필수 항목인 거리나 시간을 입력하지 않았을 때 발생합니다. 예를 들어 거리 필드를 비워두고 제출하면 "거리는 필수 입력 항목입니다"라는 메시지가 표시됩니다. 이는 사용자가 실수로 중요한 정보를 빠뜨리는 것을 방지합니다.

### VALIDATION_003: 값이 너무 작음

입력값이 허용된 최소값보다 작을 때 발생합니다. 예를 들어 거리를 0.005km로 입력하면 "거리는 0.01km 이상이어야 합니다"라는 메시지가 표시됩니다. 음수 값을 입력한 경우에도 이 오류가 발생합니다.

### VALIDATION_004: 값이 너무 큼

입력값이 허용된 최대값을 초과할 때 발생합니다. 예를 들어 거리를 1,001km로 입력하면 "거리는 1000km 이하여야 합니다"라는 메시지가 표시됩니다. 이는 비현실적으로 큰 값이나 실수로 단위를 잘못 입력한 경우를 잡아냅니다.

### VALIDATION_005: 형식 오류

입력값의 형식이 올바르지 않을 때 발생합니다. 예를 들어 날짜를 "2024/01/15" 형식으로 입력하면 ISO 8601 형식이 아니므로 "날짜 형식이 올바르지 않습니다"라는 오류가 표시됩니다. 이메일, 날짜, URL 등 특정 형식이 요구되는 필드에서 주로 발생합니다.

### VALIDATION_006: GPS 좌표 오류

GPS 좌표가 유효 범위를 벗어나거나 형식이 잘못되었을 때 발생합니다. 예를 들어 위도가 95도이거나 경도가 -200도이면 "GPS 좌표가 유효하지 않습니다"라는 메시지가 표시됩니다. 이는 GPS 센서 오류나 데이터 손상을 감지합니다.

### VALIDATION_007: 경로 데이터 크기 초과

GPS 경로에 포함된 좌표 개수가 10,000개를 초과할 때 발생합니다. "경로 데이터가 너무 큽니다"라는 메시지와 함께 요청이 거부되며, 사용자에게 운동을 여러 개로 나누어 기록하도록 안내합니다.

### VALIDATION_008: 날짜 범위 오류

startDate가 endDate보다 늦거나, 날짜가 허용 범위(2020-01-01 ~ 내일)를 벗어날 때 발생합니다. "날짜 범위가 유효하지 않습니다"라는 메시지가 표시되며, 사용자가 조회 조건을 수정하도록 유도합니다.

### VALIDATION_009: 비현실적인 페이스

계산된 페이스가 1분/km보다 빠르거나 60분/km보다 느릴 때 발생합니다. "페이스 값이 비현실적입니다"라는 메시지가 표시되며, 사용자가 거리나 시간을 다시 확인하도록 안내합니다. 이는 단위 혼동(마일과 킬로미터)이나 입력 오류를 방지합니다.

### VALIDATION_010: 거리와 시간 불일치

직접 입력한 페이스 값이 거리와 시간으로 계산한 값과 0.5분/km 이상 차이날 때 발생합니다. "거리와 시간이 일치하지 않습니다"라는 메시지가 표시되며, 이는 데이터 조작이나 입력 실수를 감지합니다.

### GPS_001: 권한 거부

사용자가 브라우저의 위치 권한 요청을 거부했을 때 발생합니다. "GPS 권한이 거부되었습니다. 설정에서 위치 권한을 허용해주세요"라는 메시지와 함께, 운영체제별 설정 방법을 안내하는 가이드가 표시됩니다.

### GPS_002: GPS 사용 불가

기기에서 GPS를 지원하지 않거나 GPS 센서가 고장났을 때 발생합니다. "이 기기에서는 GPS를 사용할 수 없습니다"라는 메시지가 표시되며, 수동 입력 모드로 전환하도록 안내합니다.

### GPS_003: GPS 신호 타임아웃

10초 이내에 GPS 신호를 찾지 못했을 때 발생합니다. "GPS 신호를 찾을 수 없습니다. 실외로 이동하거나 잠시 후 다시 시도해주세요"라는 메시지가 표시되며, 실내에 있거나 건물에 가려진 경우에 자주 발생합니다.

### GPS_004: 정확도 낮음

GPS 신호는 잡혔지만 정확도가 50미터를 초과할 때 발생합니다. "GPS 정확도가 낮습니다. 실외로 이동하거나 Wi-Fi를 켜주세요"라는 메시지가 표시되며, 운동은 계속 기록되지만 경로의 정확도가 떨어질 수 있음을 경고합니다.

---

## 보안 검증

사용자 입력을 그대로 신뢰하지 않고, 보안 위협을 사전에 차단합니다.

### XSS(Cross-Site Scripting) 방지

제목 필드는 HTML 태그를 입력받을 수 있는 텍스트 필드이므로, XSS 공격의 주요 대상입니다. 시스템은 입력된 제목에서 모든 HTML 태그를 자동으로 제거합니다. 예를 들어 사용자가 "<script>alert('xss')</script>Morning Run"이라고 입력하면, 스크립트 태그는 제거되고 "Morning Run"만 저장됩니다. 또한 꺾쇠 괄호 자체를 포함하는 입력도 거부하여, 태그 제거 후에도 위험이 남지 않도록 합니다. 이는 악의적인 사용자가 다른 사용자의 브라우저에서 스크립트를 실행하는 것을 방지합니다.

### SQL Injection 방지

데이터베이스 쿼리를 실행할 때, 사용자 입력을 직접 쿼리 문자열에 포함시키지 않습니다. 대신 파라미터화된 쿼리(Prepared Statement)를 사용하여, 입력값이 쿼리의 일부로 해석되지 않고 단순한 데이터로만 취급되도록 합니다. 예를 들어 "SELECT * FROM workouts WHERE id = ?"라는 쿼리에 ID 값을 바인딩하면, 사용자가 악의적으로 "1; DROP TABLE workouts;"를 입력하더라도 이는 단순한 문자열로 처리되어 테이블 삭제 명령이 실행되지 않습니다. 이는 데이터베이스를 악의적인 공격으로부터 보호합니다.

---

## 검증 책임 분리

검증은 프론트엔드와 백엔드에서 각각 다른 목적으로 수행됩니다.

### 프론트엔드 검증

프론트엔드의 주요 목적은 사용자 경험 개선입니다. 사용자가 입력하는 즉시 실시간으로 검증을 수행하여, 잘못된 값을 입력하면 서버에 요청을 보내기 전에 바로 오류 메시지를 표시합니다. 이를 통해 사용자는 빠른 피드백을 받을 수 있고, 불필요한 네트워크 요청을 줄여 서버 부하도 감소시킵니다.

프론트엔드는 필드의 타입이 올바른지, 필수 필드가 입력되었는지, 값이 최소/최대 범위 내에 있는지, 형식이 올바른지를 검사합니다. 또한 여러 필드 간의 관계(예: 페이스가 거리와 시간과 일치하는지)도 확인합니다. 이 모든 검증은 사용자가 입력 필드에서 포커스를 벗어날 때(onBlur) 또는 폼을 제출할 때 실행됩니다.

그러나 프론트엔드 검증만으로는 보안을 보장할 수 없습니다. 개발자 도구를 사용하거나 API를 직접 호출하면 프론트엔드 검증을 우회할 수 있기 때문입니다. 따라서 프론트엔드 검증은 사용자 경험을 위한 것이지, 보안을 위한 것이 아닙니다.

### 백엔드 검증

백엔드의 주요 목적은 보안과 데이터 무결성 보장입니다. 클라이언트에서 전송된 모든 데이터를 신뢰하지 않고, 프론트엔드와 동일한 검증을 다시 한 번 수행합니다. 이를 "다층 방어(Defense in Depth)" 전략이라고 합니다.

백엔드는 프론트엔드의 모든 검증 규칙을 재실행할 뿐만 아니라, 추가적인 검증도 수행합니다. 사용자가 해당 리소스에 접근할 권한이 있는지(Authorization), 데이터베이스에 중복된 데이터가 없는지(비즈니스 로직), SQL Injection이나 XSS 공격 시도는 없는지(보안 검증), 요청 빈도가 과도하지 않은지(Rate Limiting), 전송된 데이터 크기가 적절한지(Payload 크기 제한) 등을 확인합니다.

또한 백엔드는 GPS 데이터의 현실성도 검증합니다. 계산된 이동 속도가 인간의 능력 범위 내에 있는지, 연속된 GPS 좌표 사이에 비정상적인 점프가 없는지를 확인하여, 조작된 데이터나 오류 데이터를 걸러냅니다.

백엔드 검증이 실패하면 상세한 에러 정보를 로그에 기록하지만, 클라이언트에는 일반화된 메시지만 전송합니다. 예를 들어 개발 환경에서는 "Field 'distance' failed validation: value -5 is less than minimum 0.01"이라는 상세 메시지를 표시하지만, 프로덕션 환경에서는 "입력값이 올바르지 않습니다"라는 간단한 메시지만 전송합니다. 이는 공격자에게 시스템의 내부 구조나 검증 로직을 노출하지 않기 위함입니다.

### 클라이언트를 신뢰하지 않는 이유

프론트엔드는 사용자의 브라우저에서 실행되므로, 사용자가 완전히 제어할 수 있습니다. 브라우저의 개발자 도구를 열어 JavaScript 코드를 수정하거나, 검증 로직을 건너뛰거나, 직접 API 엔드포인트에 HTTP 요청을 보낼 수 있습니다. 따라서 프론트엔드 검증은 선량한 사용자의 실수를 방지하는 데는 효과적이지만, 악의적인 사용자의 공격을 막을 수는 없습니다. 이것이 백엔드에서 모든 검증을 다시 수행해야 하는 이유입니다.

---

## 핵심 원칙

검증 시스템은 네 가지 핵심 원칙을 기반으로 설계되었습니다.

### 1. 다층 방어 (Defense in Depth)

보안은 단일 방어선에 의존하지 않고, 여러 계층에서 검증을 수행합니다. 첫 번째 계층은 프론트엔드로, 사용자 경험을 개선하고 명백한 오류를 조기에 잡아냅니다. 두 번째 계층은 백엔드로, 보안과 데이터 무결성을 보장합니다. 세 번째 계층은 데이터베이스 제약 조건으로, NOT NULL, UNIQUE, FOREIGN KEY 등을 통해 데이터의 일관성을 유지합니다. 한 계층이 뚫리더라도 다음 계층에서 차단할 수 있도록 설계되었습니다.

### 2. 클라이언트를 신뢰하지 않음 (Never Trust Client)

서버는 클라이언트에서 전송된 어떤 데이터도 신뢰하지 않습니다. 모든 입력은 잠재적으로 악의적이거나 오류가 있을 수 있다고 가정하고, 철저히 검증합니다. 이는 프론트엔드 검증을 우회하는 공격을 방지하고, 버그나 네트워크 오류로 인한 데이터 손상도 감지합니다. "의심하고 검증하라(Doubt and Verify)"는 보안의 기본 원칙입니다.

### 3. 빠른 실패 (Fail Fast)

잘못된 입력을 발견하면 즉시 거부하고 명확한 오류 메시지를 반환합니다. 이는 리소스 낭비를 방지하고, 오류의 원인을 빠르게 파악할 수 있게 합니다. 예를 들어 거리가 음수라면 데이터베이스 쿼리를 실행하기 전에 즉시 검증 오류를 반환하여, 불필요한 데이터베이스 부하를 줄입니다. 또한 사용자는 무엇이 잘못되었는지 명확히 알 수 있어 수정이 쉬워집니다.

### 4. 명확한 오류 메시지 (Clear Error Messages)

오류 메시지는 환경에 따라 다르게 제공됩니다. 개발 환경에서는 디버깅을 위해 상세한 기술 정보를 표시합니다. 예를 들어 "Field 'distance' validation failed: expected number >= 0.01, received -5"와 같이 정확히 무엇이 잘못되었는지 알려줍니다. 반면 프로덕션 환경에서는 공격자에게 시스템 정보를 노출하지 않기 위해 일반화된 메시지를 사용합니다. 사용자에게는 "거리는 0.01km 이상이어야 합니다"처럼 이해하기 쉬운 한글 메시지를 표시하고, 서버 로그에는 민감한 정보를 마스킹한 후 상세 정보를 기록합니다.

---

## 실제 적용 예시

이론을 실제 코드로 어떻게 구현하는지 살펴보겠습니다.

### 프론트엔드 사용 예시

React 애플리케이션에서는 React Hook Form과 Zod를 결합하여 사용합니다. 먼저 useForm 훅을 호출할 때 zodResolver를 전달하여 검증 스키마를 연결합니다. 이렇게 하면 사용자가 폼을 제출할 때 자동으로 Zod 스키마에 따라 검증이 수행됩니다. 검증 실패 시 errors 객체에 필드별 오류 메시지가 담기며, 이를 화면에 표시합니다. mode를 'onBlur'로 설정하면 사용자가 입력 필드에서 포커스를 벗어날 때마다 실시간으로 검증을 수행하여, 즉각적인 피드백을 제공합니다.

폼 제출 시 handleSubmit 함수가 먼저 클라이언트 측 검증을 수행하고, 통과하면 onSubmit 콜백을 호출합니다. 이때 API 서버에 데이터를 전송하며, 서버에서 추가 검증을 수행합니다. 서버 검증 실패 시 try-catch 블록에서 오류를 잡아 사용자에게 표시합니다.

### 백엔드 사용 예시

Express 서버에서는 validate 미들웨어를 라우트 핸들러 앞에 배치합니다. 예를 들어 "POST /api/workouts" 엔드포인트는 먼저 validate(CreateWorkoutSchema, 'body')를 거치고, 검증이 통과하면 실제 핸들러 함수가 실행됩니다. validate 미들웨어는 요청 body를 Zod 스키마로 검증하고, 실패 시 자동으로 400 상태 코드와 함께 에러 응답을 반환합니다. 검증이 성공하면 req.body는 스키마에 정의된 타입으로 변환되고 정제된(sanitized) 데이터를 포함하게 됩니다.

이렇게 하면 라우트 핸들러 함수 내부에서는 이미 검증된 데이터만 다루게 되므로, 추가적인 타입 체크나 검증 로직이 필요 없습니다. 코드가 간결해지고, 검증 로직을 재사용할 수 있으며, 실수로 검증을 빠뜨릴 위험도 줄어듭니다.

---

## 파일 구조

검증 관련 코드는 체계적으로 구조화되어 있습니다.

### 프론트엔드 파일

타입 정의는 src/types/errors.ts에 위치하며, ErrorType과 ErrorCode 열거형, AppError와 FormErrorState 인터페이스, 에러 코드별 한글 메시지 매핑을 포함합니다. 검증 스키마는 src/schemas/ 디렉터리에 위치하며, workout.schema.ts에 ManualWorkoutSchema, LiveWorkoutSetupSchema, WorkoutSubmitSchema 등 5개의 Zod 스키마가 정의되어 있습니다. 에러 처리 유틸리티는 src/utils/errorHandler.ts에 위치하며, API 에러를 AppError로 변환하고, 재시도 로직을 제공하고, GPS 에러를 처리하는 함수들이 포함되어 있습니다.

### 백엔드 파일

에러 클래스는 server/src/types/errors.js에 정의되어 있으며, AppError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError, DatabaseError 등 6개의 클래스가 있습니다. 검증 스키마는 server/src/schemas/ 디렉터리에 위치하며, workout.schema.js에 CreateWorkoutSchema, UpdateWorkoutSchema, WorkoutQuerySchema, WorkoutIdSchema 등 4개의 Zod 스키마가 정의되어 있습니다. 미들웨어는 server/src/middleware/ 디렉터리에 위치하며, validate.js는 요청 데이터를 검증하고, errorHandler.js는 전역 에러 핸들러로 모든 에러를 잡아 적절한 응답을 생성합니다.

---

## 실무 체크리스트

새로운 기능을 추가할 때 검증 관련 작업을 빠뜨리지 않도록 체크리스트를 따릅니다.

### 새 필드 추가 시

프론트엔드 Zod 스키마에 새 필드의 검증 규칙을 추가합니다. 백엔드 Zod 스키마에도 동일한 규칙을 추가하여 이중 검증을 보장합니다. 필요한 경우 src/types/errors.ts에 새로운 에러 코드를 정의하고, ERROR_MESSAGES와 FIELD_ERROR_MESSAGES에 한글 메시지를 추가합니다. 새 필드에 대한 단위 테스트를 작성하여 유효한 값과 무효한 값을 모두 테스트합니다. 마지막으로 API 문서를 업데이트하여 새 필드의 타입, 필수 여부, 범위, 형식을 명시합니다.

### 새 API 엔드포인트 추가 시

요청 body, query 파라미터, URL 파라미터에 대한 Zod 스키마를 정의합니다. 라우트 핸들러에 validate 미들웨어를 적용하여 자동 검증을 활성화합니다. 리소스에 대한 접근 권한을 확인하는 Authorization 미들웨어를 추가합니다. 에러 핸들링을 추가하여 모든 예외 상황을 적절히 처리합니다. 로깅 시 비밀번호, 토큰, 개인 GPS 좌표 등 민감한 데이터가 노출되지 않도록 마스킹합니다. 통합 테스트를 작성하여 성공 케이스와 실패 케이스를 모두 검증합니다.

---

## 결론

Good Ruck 애플리케이션의 검증 시스템은 사용자 경험과 보안을 동시에 고려하여 설계되었습니다. 프론트엔드는 빠른 피드백으로 사용자를 돕고, 백엔드는 철저한 검증으로 시스템을 보호합니다. 7개의 주요 필드, 14개의 에러 코드, 3가지 교차 검증 규칙, 2가지 보안 검증이 유기적으로 결합되어 안정적인 데이터 처리를 보장합니다.

다층 방어, 클라이언트 불신, 빠른 실패, 명확한 메시지라는 네 가지 핵심 원칙을 준수하며, 실무에서 검증 로직을 일관되게 적용할 수 있도록 체계적인 파일 구조와 체크리스트를 제공합니다. 이를 통해 개발자는 보일러플레이트 코드를 줄이고, 사용자는 직관적인 오류 메시지를 받으며, 시스템은 악의적인 공격으로부터 안전하게 보호됩니다.
