# 테스트 전략 가이드 - 상세 설명

## 개요

Good Ruck 애플리케이션의 테스트 전략은 신뢰할 수 있고 유지보수 가능한 코드베이스를 구축하기 위한 체계적인 접근 방식입니다. 테스트는 단순히 버그를 찾는 도구가 아니라, 코드 품질을 보장하고 리팩토링을 안전하게 만들며 팀의 개발 속도를 장기적으로 향상시키는 투자입니다. 우리는 테스트 피라미드 모델을 따라 70%의 단위 테스트, 20%의 통합 테스트, 10%의 E2E 테스트로 균형 잡힌 테스트 스위트를 구축합니다.

## 테스트 피라미드: 균형 잡힌 테스트 전략

테스트 피라미드는 마틴 파울러가 대중화한 개념으로, 테스트 유형 간의 이상적인 비율을 시각화합니다. 피라미드의 기저부가 가장 넓고 정점으로 갈수록 좁아지는 형태는 각 레벨의 테스트가 차지해야 할 비율을 나타냅니다.

### 단위 테스트 (70% - 피라미드의 기저)

단위 테스트는 전체 테스트 스위트의 70%를 차지하며, 가장 많은 수의 테스트가 이 레벨에 위치합니다. 단위 테스트는 개별 함수, 유틸리티, 훅, 클래스를 격리된 환경에서 테스트합니다. 이 테스트들은 매우 빠르게 실행되며(밀리초 단위), 외부 의존성 없이 순수한 로직만을 검증합니다.

단위 테스트가 가장 많아야 하는 이유는 명확합니다. 실행 속도가 빠르고 작성이 쉬우며 유지보수가 간단하고 실패 시 문제의 원인을 정확히 파악할 수 있습니다. 개발자는 코드를 작성하면서 즉시 피드백을 받을 수 있어 TDD(Test-Driven Development)에 이상적입니다.

Good Ruck에서 단위 테스트의 대상은 다음과 같습니다. workoutStats.ts의 순수 함수들(calculatePace, groupByWeek, calculateAverageWeight)은 입력에 대해 예측 가능한 출력을 생성하므로 단위 테스트에 완벽합니다. gpsValidation.ts의 GPS 좌표 검증, 정확도 확인, 속도 검증 함수들도 독립적으로 테스트할 수 있습니다. Zod 스키마의 검증 로직, 에러 변환 유틸리티, 토큰 관리 클래스도 모두 단위 테스트로 커버됩니다.

단위 테스트 작성 시 각 함수는 여러 테스트 케이스를 가져야 합니다. 정상 케이스(happy path)는 기본적으로 테스트하고, 경계 값(boundary values)은 최소값, 최대값, 0, null, undefined를 테스트하며, 에러 케이스는 잘못된 입력에 대한 적절한 에러 발생을 검증합니다. 엣지 케이스는 부동소수점 정밀도, 매우 큰 배열, 특수 문자 등을 포함합니다.

### 통합 테스트 (20% - 피라미드의 중간)

통합 테스트는 전체의 20%를 차지하며, 여러 컴포넌트나 모듈이 함께 작동하는 방식을 검증합니다. 단위 테스트가 "각 부품이 올바르게 작동하는가?"를 묻는다면, 통합 테스트는 "부품들이 함께 올바르게 작동하는가?"를 묻습니다.

프론트엔드 통합 테스트는 React Testing Library를 사용하여 컴포넌트와 그들의 의존성(context, hooks, API 호출)을 함께 테스트합니다. 예를 들어, AddWorkoutModal 컴포넌트는 React Hook Form, Zod 검증, API 호출, 에러 핸들링을 모두 포함하므로 통합 테스트가 적합합니다. 사용자가 폼을 채우고 제출하는 전체 플로우를 시뮬레이션하여 실제 사용 시나리오를 검증합니다.

백엔드 통합 테스트는 supertest를 사용하여 실제 HTTP 요청을 시뮬레이션합니다. API 엔드포인트, 미들웨어 체인, 데이터베이스 상호작용을 함께 테스트합니다. POST /api/workouts 엔드포인트를 테스트할 때, 요청 본문 파싱, Zod 검증 미들웨어, 라우트 핸들러, 데이터베이스 삽입, 응답 포맷팅이 모두 실제로 실행됩니다.

통합 테스트는 단위 테스트보다 느리지만(수백 밀리초에서 수 초), 여전히 합리적인 시간 내에 실행됩니다. 이들은 실제 환경에 가까운 조건에서 테스트하므로, 단위 테스트에서 놓칠 수 있는 통합 문제를 발견합니다. 예를 들어, 개별 함수는 정상이지만 데이터 형식이 맞지 않거나, 미들웨어 순서가 잘못되었거나, 트랜잭션이 제대로 커밋되지 않는 문제를 찾을 수 있습니다.

### E2E 테스트 (10% - 피라미드의 정점)

End-to-End 테스트는 전체의 10%만을 차지하지만, 가장 높은 확신을 제공합니다. 이들은 실제 사용자처럼 브라우저를 조작하여 전체 애플리케이션 스택을 테스트합니다. Playwright나 Cypress를 사용하여 실제 브라우저에서 프론트엔드, 백엔드, 데이터베이스가 함께 작동하는 것을 검증합니다.

E2E 테스트는 중요한 사용자 플로우에만 집중해야 합니다. Good Ruck에서는 "GPS 운동 추적 전체 플로우"가 가장 핵심적입니다. 사용자가 "Start Workout"을 클릭하고, GPS 권한을 승인하고, 운동 정보를 입력하고, 추적을 시작하고, 멈추고, 저장하는 전체 여정을 테스트합니다. "데이터 시각화 플로우"도 중요합니다. 홈 화면에서 차트가 표시되고, 기간을 전환하고, 통계가 업데이트되는 것을 검증합니다.

E2E 테스트는 가장 느립니다(수 초에서 수십 초). 실제 브라우저를 띄우고 네트워크 요청을 기다리며 렌더링을 완료해야 하기 때문입니다. 또한 가장 불안정합니다(flaky). 네트워크 지연, 타이밍 이슈, 외부 의존성 때문에 간헐적으로 실패할 수 있습니다. 따라서 E2E 테스트는 절대 실패하면 안 되는 핵심 플로우에만 사용하고, 세부 기능은 단위 테스트와 통합 테스트로 커버합니다.

## 커버리지 목표: 현실적이면서도 의미 있는 지표

코드 커버리지는 테스트가 실행하는 코드의 비율을 측정합니다. 100% 커버리지가 이상적으로 보이지만, 현실적이지도 않고 필요하지도 않습니다. 우리는 80%의 전체 커버리지를 목표로 하되, 중요도에 따라 차등을 둡니다.

### 유틸리티 함수 (90% 목표, 크리티컬 패스 100%)

유틸리티 함수는 애플리케이션 전반에서 재사용되므로 매우 높은 커버리지가 필요합니다. calculatePace, groupByWeek, formatDate 같은 함수는 여러 컴포넌트에서 사용되므로, 한 곳의 버그가 여러 곳에 영향을 미칩니다. 90% 커버리지는 거의 모든 브랜치와 조건을 테스트한다는 의미입니다.

크리티컬 패스는 100% 커버리지를 요구합니다. 예를 들어, 결제 관련 계산, 보안 검증, GPS 좌표 검증처럼 실패 시 심각한 결과를 초래하는 함수는 모든 엣지 케이스를 테스트해야 합니다. isValidCoordinate 함수는 잘못된 GPS 데이터가 데이터베이스에 저장되는 것을 막는 마지막 방어선이므로 모든 경계 조건(위도 -90~90, 경도 -180~180, NaN, null)을 테스트합니다.

### 서비스 레이어 (85% 목표, 크리티컬 패스 95%)

서비스 레이어는 비즈니스 로직과 외부 의존성(API, 데이터베이스)의 상호작용을 담당합니다. GPSManager 클래스, API 서비스, 데이터 변환 로직이 여기에 속합니다. 85% 커버리지는 주요 시나리오와 에러 처리를 모두 테스트한다는 의미입니다.

GPSManager는 실제 Geolocation API 대신 모킹된 버전을 사용하여 테스트합니다. 정상적인 위치 획득, 권한 거부, 타임아웃, 낮은 정확도 등의 시나리오를 모두 시뮬레이션합니다. 이를 통해 실제 디바이스 없이도 모든 GPS 시나리오를 검증할 수 있습니다.

### 컴포넌트 (75% 목표, 크리티컬 패스 90%)

React 컴포넌트는 UI 로직을 포함하므로 테스트가 복잡할 수 있습니다. 75% 커버리지는 주요 사용자 상호작용과 조건부 렌더링을 테스트한다는 의미입니다. StatsCard처럼 간단한 프레젠테이션 컴포넌트는 props 렌더링만 확인하면 충분합니다. AddWorkoutModal처럼 복잡한 폼 컴포넌트는 입력, 검증, 제출, 에러 표시를 모두 테스트해야 합니다.

크리티컬 패스 컴포넌트는 90% 커버리지를 목표로 합니다. ErrorBoundary는 애플리케이션 전체의 안정성을 책임지므로 모든 에러 시나리오(렌더링 에러, 비동기 에러, 복구 시도)를 테스트해야 합니다. AuthContext는 전체 인증 상태를 관리하므로 로그인, 로그아웃, 토큰 갱신, 만료 처리를 철저히 테스트합니다.

### 훅 (85% 목표, 크리티컬 패스 95%)

커스텀 훅은 재사용 가능한 로직을 캡슐화하므로 높은 테스트 커버리지가 중요합니다. @testing-library/react-hooks를 사용하여 컴포넌트와 독립적으로 훅을 테스트할 수 있습니다. useWorkouts 훅은 데이터 페칭, 로딩 상태, 에러 처리를 포함하므로 모든 비동기 시나리오를 테스트해야 합니다.

useGPS 훅은 GPS 추적의 핵심이므로 95% 크리티컬 패스 커버리지가 필요합니다. 위치 획득, 권한 요청, 연속 추적, 정확도 필터링, 에러 처리, 클린업을 모두 검증합니다. 훅의 장점은 테스트가 UI와 분리되어 로직에만 집중할 수 있다는 점입니다.

### 백엔드 (80% 목표, 크리티컬 패스 90%)

백엔드 코드는 데이터 무결성과 보안에 직접적인 영향을 미치므로 견고한 테스트가 필수입니다. Express 라우트, 미들웨어, 데이터베이스 쿼리를 테스트합니다. supertest를 사용하면 실제 서버를 시작하지 않고도 HTTP 요청을 시뮬레이션할 수 있습니다.

검증 미들웨어는 잘못된 데이터가 데이터베이스에 저장되는 것을 막는 첫 번째 방어선입니다. 모든 필드의 최소값, 최대값, 타입, 포맷을 테스트해야 합니다. 인증 미들웨어는 보안의 핵심이므로 유효한 토큰, 만료된 토큰, 잘못된 토큰, 토큰 없음 등의 모든 시나리오를 테스트합니다.

## 테스트 환경 설정: 견고한 기반 구축

### Vitest 설정: 빠르고 현대적인 테스트 러너

Vitest는 Vite와 완벽하게 통합되는 테스트 프레임워크입니다. Jest와 호환되는 API를 제공하면서도 훨씬 빠르며, ES 모듈을 네이티브로 지원합니다. vitest.config.ts에서 globals: true로 설정하면 describe, it, expect를 import 없이 사용할 수 있습니다. environment: 'jsdom'은 브라우저 환경을 시뮬레이션하여 DOM API를 사용할 수 있게 합니다.

setupFiles는 모든 테스트 전에 실행되는 설정 파일을 지정합니다. src/test/setup.ts에서 @testing-library/jest-dom의 매처를 확장하여 toBeInTheDocument(), toHaveTextContent() 같은 편리한 assertion을 사용할 수 있습니다. afterEach에서 cleanup()을 호출하여 각 테스트 후 DOM을 정리하고 메모리 누수를 방지합니다.

커버리지 설정은 provider: 'v8'로 네이티브 V8 커버리지를 사용합니다. 이는 istanbul보다 빠르고 정확합니다. exclude 패턴으로 node_modules, 테스트 파일, 타입 정의, 설정 파일, 모크 데이터를 커버리지 계산에서 제외합니다. thresholds는 최소 커버리지를 강제하여 PR이 커버리지를 낮추는 것을 방지합니다.

### Playwright 설정: 신뢰할 수 있는 E2E 테스트

Playwright는 Chromium, Firefox, WebKit에서 동시에 테스트할 수 있는 강력한 E2E 도구입니다. playwright.config.ts에서 baseURL을 설정하여 모든 테스트에서 상대 경로를 사용할 수 있습니다. webServer 옵션은 테스트 실행 전에 개발 서버를 자동으로 시작하고 종료합니다.

use 섹션에서 모든 테스트의 기본 동작을 설정합니다. headless: true는 브라우저 UI 없이 백그라운드에서 실행하여 속도를 높입니다. screenshot: 'only-on-failure'는 실패한 테스트의 스크린샷만 저장하여 디버깅을 돕습니다. video: 'retain-on-failure'는 실패한 테스트의 비디오를 보관합니다.

trace: 'on-first-retry'는 테스트가 실패하고 재시도할 때 상세한 추적 정보를 수집합니다. 이 추적 파일을 Playwright Inspector에서 열면 각 단계를 시각적으로 검토하고 네트워크 요청을 확인할 수 있습니다.

## 단위 테스트: 견고한 함수 검증

### 유틸리티 함수 테스트

calculatePace 함수는 거리와 시간을 받아 분당 킬로미터를 계산합니다. 정상 케이스는 30분에 5km를 달렸을 때 6 min/km를 반환하는지 확인합니다. 경계 케이스는 거리가 0일 때 0을 반환하는지(또는 Infinity를 반환할지는 설계 결정) 확인합니다. 부동소수점 케이스는 25.5분에 5.1km를 달렸을 때 소수점 계산이 정확한지 toBeCloseTo로 검증합니다.

groupByWeek 함수는 운동 기록을 주 단위로 그룹화합니다. 테스트는 서로 다른 주의 운동들이 올바르게 분리되는지 확인합니다. 2024년 1월 1일과 3일은 같은 주이므로 합쳐지고, 8일은 다른 주이므로 분리됩니다. 각 주의 총 거리가 정확히 합산되고, 평균 페이스가 올바르게 계산되는지도 검증합니다.

calculateAverageWeight 함수는 null 값을 적절히 처리해야 합니다. 일부 운동은 무게를 기록하지 않을 수 있으므로, null이나 undefined를 제외하고 평균을 계산해야 합니다. 빈 배열에 대해서는 0을 반환하여 NaN을 방지합니다.

### GPS 검증 테스트

isValidCoordinate 함수는 GPS 데이터의 게이트키퍼입니다. 유효한 좌표 테스트는 서울(37.5665, 126.9780), Null Island(0, 0), 극단값(-90, -180과 90, 180)을 포함합니다. 무효한 좌표 테스트는 범위를 벗어난 값(위도 91, 경도 181), NaN, null, undefined를 거부하는지 확인합니다.

isAcceptableAccuracy 함수는 GPS 정확도가 임계값 이내인지 확인합니다. 10미터는 우수하고 50미터는 허용 가능하지만 51미터는 거부되어야 합니다. 0이나 음수 정확도는 유효하지 않으므로 거부됩니다.

isRealisticSpeed 함수는 GPS 스푸핑이나 신호 점프를 감지합니다. 5km를 1시간에 이동(5 km/h)은 걷기로 현실적이고, 20km를 1시간에 이동(20 km/h)은 달리기로 가능하지만, 100km를 1시간에 이동(100 km/h)은 자동차 속도이므로 거부됩니다. 시속 30km를 최대값으로 설정하여 인간의 운동으로 불가능한 속도를 필터링합니다.

## 통합 테스트: 컴포넌트와 시스템의 협력

### 폼 컴포넌트 통합 테스트

AddWorkoutModal은 여러 레이어가 협력하는 복잡한 컴포넌트입니다. React Hook Form은 폼 상태를 관리하고, Zod는 입력을 검증하며, API 서비스는 백엔드와 통신하고, 에러 핸들러는 실패를 처리합니다. 통합 테스트는 이 모든 것이 함께 작동하는지 검증합니다.

테스트는 사용자 관점에서 작성됩니다. render로 컴포넌트를 렌더링하고, screen.getByLabelText로 입력 필드를 찾고, userEvent.type으로 값을 입력합니다. 이는 실제 사용자가 타이핑하는 것을 시뮬레이션하여 onChange 이벤트, 상태 업데이트, 재렌더링을 모두 트리거합니다.

검증 에러 테스트는 잘못된 값을 입력하고 제출할 때 적절한 에러 메시지가 표시되는지 확인합니다. 거리에 -5를 입력하면 "Distance must be at least 0.01 km"가 빨간색으로 표시되어야 합니다. 이는 Zod 스키마가 올바르게 작동하고 에러가 UI에 전달되는 것을 검증합니다.

API 호출 테스트는 실제 네트워크 요청 대신 모킹을 사용합니다. vi.fn()으로 workoutAPI.createWorkout을 모킹하고, 성공 시 Promise를 resolve하고 실패 시 reject합니다. 제출 후 API가 올바른 데이터로 호출되었는지, 성공 시 모달이 닫히는지, 실패 시 에러 메시지가 표시되는지 검증합니다.

### API 서비스 통합 테스트

workoutAPI 서비스는 axios를 사용하여 백엔드와 통신합니다. 통합 테스트는 실제 서버 대신 fetch API를 모킹하여 네트워크 레이어를 시뮬레이션합니다. global.fetch = vi.fn()으로 전역 fetch를 교체하고, mockResolvedValueOnce로 응답을 설정합니다.

성공 케이스 테스트는 getWorkouts()를 호출하고, 모킹된 응답이 올바르게 반환되는지 확인합니다. fetch가 올바른 URL(/api/workouts)로 호출되었는지, 응답이 JSON 파싱되어 반환되었는지 검증합니다.

에러 케이스 테스트는 HTTP 500을 모킹하고, workoutAPI가 적절한 에러를 throw하는지 확인합니다. handleApiError가 호출되어 에러가 AppError 형식으로 변환되고, retryable 플래그가 true로 설정되는지 검증합니다.

재시도 로직 테스트는 withRetry 함수가 실패한 요청을 자동으로 재시도하는지 확인합니다. 첫 두 번은 실패하고 세 번째에 성공하는 시나리오를 모킹합니다. 지수 백오프가 올바르게 적용되는지(1초, 2초, 4초 대기) 확인하고, 최대 재시도 횟수 후에는 에러를 throw하는지 검증합니다.

## E2E 테스트: 실제 사용자 경험 검증

### 운동 추적 플로우

전체 운동 추적 플로우는 Good Ruck의 핵심 기능입니다. 테스트는 실제 사용자처럼 브라우저를 조작합니다. test.beforeEach에서 GPS 권한을 사전에 승인하고(context.grantPermissions), 모킹된 위치를 서울로 설정합니다(context.setGeolocation).

사용자는 홈 화면에서 "Start Workout"을 클릭합니다. 이는 /live-workout 페이지로 라우팅되고 GPS 상태가 표시됩니다. await expect(page.locator('text=GPS')).toBeVisible()로 GPS 컴포넌트가 렌더링되는지 확인합니다.

운동 정보 입력 단계에서 제목과 무게를 입력합니다. page.fill('input[name="title"]', 'Morning Run')은 실제 키보드 입력을 시뮬레이션합니다. "Continue to Tracking"을 클릭하면 추적 화면으로 전환됩니다.

추적 단계에서 "Start Workout"을 클릭하면 GPS 추적이 시작됩니다. "Recording" 표시가 나타나고 거리와 시간이 실시간으로 업데이트됩니다. page.waitForTimeout(2000)으로 일정 시간 추적을 시뮬레이션합니다. 실제 테스트에서는 시간을 모킹하거나 이벤트를 트리거하여 실제 대기 시간을 줄일 수 있습니다.

저장 단계에서 "Stop"을 클릭하면 추적이 종료되고 "Workout Saved" 메시지가 표시됩니다. "Go Back"으로 홈 화면으로 돌아가면 방금 생성한 "Morning Run" 운동이 목록에 표시되는지 확인합니다. 이는 전체 데이터 흐름(프론트엔드 → API → 데이터베이스 → API → 프론트엔드)이 작동하는 것을 검증합니다.

### GPS 권한 거부 플로우

GPS 권한 거부는 반드시 우아하게 처리해야 하는 중요한 엣지 케이스입니다. context.clearPermissions()로 모든 권한을 취소한 후 /live-workout으로 이동합니다. GPS를 요청하면 권한 거부 에러가 발생하고, GPSPermissionDenied 컴포넌트가 렌더링되어야 합니다.

화면에는 "GPS 권한이 필요합니다"라는 명확한 제목과 함께 "권한 허용하기" 버튼이 표시되어야 합니다. "권한 설정 방법" 버튼을 클릭하면 플랫폼별(Chrome/Safari) 안내가 펼쳐집니다. 이러한 명확한 안내는 사용자가 문제를 스스로 해결할 수 있게 합니다.

### 데이터 시각화 플로우

홈 화면의 차트는 사용자의 운동 패턴을 시각화합니다. "Activity Overview" 제목이 표시되고, "7 Days"와 "Weekly" 토글 버튼이 있어야 합니다. .recharts-wrapper 클래스로 Recharts 라이브러리의 차트가 렌더링되었는지 확인합니다.

"Weekly" 버튼을 클릭하면 일간 뷰에서 주간 뷰로 전환됩니다. 차트가 재렌더링되고 데이터가 주별로 집계되어 표시됩니다. 이는 groupByWeek 함수와 차트 컴포넌트가 함께 작동하는 것을 검증합니다.

## 백엔드 테스트: API의 신뢰성 보장

### supertest를 사용한 API 테스트

supertest는 Express 애플리케이션을 실제 서버로 시작하지 않고도 HTTP 요청을 테스트할 수 있게 합니다. require('../app')로 Express app을 가져오되, app.listen()은 호출하지 않습니다. supertest가 자체 서버를 생성하여 요청을 처리합니다.

POST /api/workouts 테스트는 유효한 운동 데이터를 전송하고 201 Created 응답을 기대합니다. request(app).post('/api/workouts').send(newWorkout).expect(201)은 요청, 응답, 검증을 한 줄로 체이닝합니다. 응답 본문은 생성된 운동 객체를 포함하며, expect(response.body).toMatchObject로 id가 할당되었는지, 입력 데이터가 올바르게 저장되었는지 확인합니다.

검증 실패 테스트는 거리가 음수인 잘못된 데이터를 전송합니다. 백엔드는 400 Bad Request를 반환하고, error 필드는 'VALIDATION_ERROR'여야 합니다. details 배열에는 어떤 필드가 왜 잘못되었는지 상세 정보가 포함됩니다.

여러 검증 에러 테스트는 거리, 시간, 무게가 모두 유효하지 않은 데이터를 전송합니다. details 배열에 세 개의 에러가 포함되는지 확인하여 모든 검증 에러가 수집되어 한 번에 반환되는지 검증합니다. 이는 사용자가 한 번에 모든 문제를 알 수 있어 UX가 향상됩니다.

### 데이터베이스 통합 테스트

테스트 데이터베이스는 프로덕션과 격리되어야 합니다. beforeAll에서 테스트 전용 테이블을 생성하고, afterAll에서 삭제합니다. 또는 :memory: 데이터베이스를 사용하여 각 테스트 실행이 완전히 독립적이게 할 수 있습니다.

DELETE /api/workouts/:id 테스트는 먼저 운동을 생성하고, 그 ID로 삭제 요청을 보내고, GET 요청으로 실제로 삭제되었는지 확인하는 3단계 과정입니다. 이는 CRUD 작업의 완전한 라운드트립을 검증합니다.

존재하지 않는 리소스 삭제는 404 Not Found를 반환해야 합니다. DELETE /api/workouts/99999는 존재할 가능성이 없는 ID로 요청하고 404를 기대합니다. 이는 NotFoundError가 올바르게 처리되는지 검증합니다.

## 모킹 전략: 효율적인 테스트 격리

### 외부 의존성 모킹

테스트는 외부 시스템에 의존하지 않아야 합니다. 실제 API를 호출하면 테스트가 느려지고, 네트워크 상태에 따라 불안정해지며, 외부 서비스에 부하를 줍니다. Vitest의 vi.fn()은 함수를 모킹하고 호출을 추적할 수 있게 합니다.

axios.get을 모킹하려면 vi.spyOn(axios, 'get').mockResolvedValue({ data: mockData })를 사용합니다. 이는 실제 axios.get 호출을 가로채어 모킹된 데이터를 반환합니다. 네트워크 요청 없이 즉시 응답하므로 테스트가 밀리초 단위로 실행됩니다.

### GPS API 모킹

Geolocation API는 브라우저 내장 API이므로 테스트 환경에서 사용할 수 없습니다. 모킹하지 않으면 테스트가 실패합니다. global.navigator.geolocation을 모킹하여 getCurrentPosition과 watchPosition을 가짜 구현으로 교체합니다.

성공 케이스는 즉시 콜백을 호출하여 모킹된 위치를 반환합니다. 에러 케이스는 에러 콜백을 호출하여 권한 거부나 타임아웃을 시뮬레이션합니다. 이를 통해 모든 GPS 시나리오를 테스트 환경에서 재현할 수 있습니다.

### 타이머 모킹

setTimeout, setInterval을 사용하는 코드는 실제 시간을 기다리면 테스트가 느려집니다. vi.useFakeTimers()는 시간을 모킹하여 즉시 제어할 수 있게 합니다. withRetry의 지수 백오프를 테스트할 때, vi.advanceTimersByTime(1000)으로 1초를 즉시 건너뛸 수 있습니다.

vi.runAllTimers()는 모든 대기 중인 타이머를 즉시 실행하여 테스트를 동기적으로 만듭니다. 이는 비동기 코드를 테스트하기 쉽게 만들면서도 실제 대기 시간을 제거합니다.

## CI/CD 통합: 자동화된 품질 보장

### GitHub Actions 워크플로우

모든 PR은 자동으로 테스트를 실행해야 합니다. .github/workflows/test.yml 파일은 코드가 푸시될 때마다 트리거되는 워크플로우를 정의합니다. jobs 섹션에서 test 작업은 Ubuntu 최신 버전에서 실행됩니다.

actions/checkout@v3은 저장소 코드를 체크아웃합니다. actions/setup-node@v3은 Node.js 18을 설치합니다. npm ci는 package-lock.json을 기반으로 의존성을 설치하여 재현 가능한 빌드를 보장합니다.

테스트 실행은 npm test로 단위 테스트와 통합 테스트를 실행하고, npm run test:e2e로 E2E 테스트를 실행합니다. continue-on-error: false로 설정하여 테스트 실패 시 워크플로우를 중단합니다. 이는 실패한 테스트가 있는 PR이 병합되는 것을 방지합니다.

커버리지 리포트는 codecov/codecov-action을 사용하여 Codecov에 업로드됩니다. PR에 코멘트로 커버리지 변화를 표시하여 리뷰어가 테스트 품질을 쉽게 확인할 수 있습니다.

### 병렬 실행 최적화

테스트 스위트가 커지면 실행 시간도 늘어납니다. GitHub Actions의 matrix 전략을 사용하여 여러 작업을 병렬로 실행할 수 있습니다. 예를 들어, 단위 테스트, 통합 테스트, E2E 테스트를 각각 독립적인 job으로 분리하면 전체 시간이 크게 단축됩니다.

Playwright는 기본적으로 병렬 실행을 지원합니다. workers: 4로 설정하면 4개의 테스트를 동시에 실행하여 E2E 테스트 시간을 1/4로 줄일 수 있습니다. 단, 메모리 사용량이 증가하므로 CI 환경의 리소스를 고려해야 합니다.

## 테스트 작성 모범 사례

### AAA 패턴: Arrange-Act-Assert

모든 테스트는 세 단계로 구성되어야 합니다. Arrange(준비) 단계에서 테스트에 필요한 데이터와 환경을 설정합니다. mockWorkouts 데이터를 생성하고, 컴포넌트를 렌더링하고, 모킹을 설정합니다.

Act(실행) 단계에서 테스트하려는 동작을 수행합니다. 함수를 호출하거나, 버튼을 클릭하거나, API 요청을 보냅니다. 이 단계는 가능한 한 간단하고 명확해야 하며, 한 가지 동작에만 집중합니다.

Assert(검증) 단계에서 결과가 예상과 일치하는지 확인합니다. expect로 assertion을 작성하며, 구체적이고 명확한 메시지를 제공합니다. "에러가 발생해야 한다" 대신 "거리가 음수일 때 VALIDATION_003 에러가 발생해야 한다"처럼 구체적으로 작성합니다.

### 테스트 독립성

각 테스트는 독립적으로 실행 가능해야 합니다. 테스트 A가 실패해도 테스트 B는 영향받지 않아야 하고, 실행 순서가 바뀌어도 결과가 같아야 합니다. beforeEach로 각 테스트 전에 깨끗한 상태를 보장하고, afterEach로 정리합니다.

전역 상태를 피합니다. 테스트 간에 공유되는 변수나 모킹은 예상치 못한 상호작용을 일으킬 수 있습니다. 각 테스트는 자신만의 데이터와 모킹을 설정해야 합니다.

### 설명적인 테스트 이름

테스트 이름은 실패했을 때 무엇이 문제인지 즉시 알 수 있어야 합니다. "should work"는 나쁜 이름입니다. "should calculate correct pace for 30 minutes and 5 kilometers"는 좋은 이름입니다. 이름만 봐도 입력, 동작, 기대 결과를 알 수 있습니다.

네이밍 규칙을 일관되게 유지합니다. "should [동작] when [조건]" 패턴을 사용하면 가독성이 높아집니다. "should return 404 when workout does not exist"처럼 작성하면 테스트의 의도가 명확해집니다.

### 적절한 assertion 사용

toBe는 원시 값이나 참조 동일성을 비교합니다. toEqual은 객체의 내용을 깊이 비교합니다. 객체를 테스트할 때는 toEqual을 사용하고, 특정 필드만 확인하려면 toMatchObject를 사용합니다.

toBeCloseTo는 부동소수점 비교에 필수입니다. 0.1 + 0.2는 정확히 0.3이 아니므로 expect(result).toBe(0.3)은 실패할 수 있습니다. expect(result).toBeCloseTo(0.3, 1)로 소수점 한 자리까지만 비교하면 안전합니다.

## 결론

체계적인 테스트 전략은 Good Ruck 애플리케이션의 장기적인 성공을 보장합니다. 테스트 피라미드를 따라 70%의 빠른 단위 테스트, 20%의 통합 테스트, 10%의 E2E 테스트로 균형을 맞춥니다. 80%의 전체 커버리지를 목표로 하되, 중요한 코드는 더 높은 커버리지를 요구합니다.

Vitest와 Playwright를 사용하여 현대적이고 빠른 테스트 환경을 구축합니다. 단위 테스트는 순수 함수와 유틸리티를, 통합 테스트는 컴포넌트와 API를, E2E 테스트는 핵심 사용자 플로우를 검증합니다. 모킹을 적절히 사용하여 외부 의존성을 격리하고 테스트를 빠르고 안정적으로 만듭니다.

CI/CD 파이프라인과 통합하여 모든 PR이 자동으로 테스트되고, 커버리지가 추적되며, 실패한 테스트가 있는 코드는 병합되지 않도록 합니다. AAA 패턴, 테스트 독립성, 설명적인 이름, 적절한 assertion을 따라 유지보수 가능한 테스트를 작성합니다.

테스트는 개발 속도를 늦추는 것이 아니라, 장기적으로 가속화합니다. 버그를 조기에 발견하고, 리팩토링을 안전하게 수행하며, 새로운 기능 추가 시 기존 기능의 손상을 방지합니다. 잘 작성된 테스트 스위트는 코드베이스에 대한 신뢰를 제공하고, 팀이 자신감 있게 변경할 수 있게 합니다.
