# 보안 통제 가이드 - 상세 설명

## 개요

Good Ruck 애플리케이션은 사용자의 민감한 개인정보를 다루는 GPS 기반 운동 추적 서비스입니다. GPS 위치 기록, 운동 데이터, 사용자 인증 정보 등은 모두 높은 수준의 보호가 필요한 자산입니다. 이 문서는 STRIDE 위협 모델링 프레임워크를 기반으로 설계된 포괄적인 보안 통제 시스템을 설명합니다.

## 위협 모델링: STRIDE 분석

STRIDE는 마이크로소프트가 개발한 위협 분류 프레임워크로, 여섯 가지 주요 위협 카테고리를 통해 시스템의 보안 취약점을 체계적으로 분석합니다. Good Ruck 애플리케이션에 대해 총 22개의 위협을 식별하고 각각에 대한 완화 전략을 수립했습니다.

### Spoofing (신원 위조)

신원 위조는 공격자가 정당한 사용자인 것처럼 가장하여 시스템에 접근하는 위협입니다. 이는 애플리케이션 보안에서 가장 심각한 위협 중 하나이며, 계정 탈취로 이어질 수 있습니다.

**자격 증명 도용(S1)**은 피싱이나 키로깅을 통해 사용자의 이메일과 비밀번호를 훔치는 공격입니다. 이 위협의 발생 가능성은 중간 수준이지만, 영향도는 치명적입니다. 완화 전략으로 강력한 비밀번호 정책을 적용하고, 로그인 시도에 대한 속도 제한을 설정하며, 향후 다중 인증(MFA)을 도입할 계획입니다. 비밀번호는 bcrypt 알고리즘으로 해시하여 저장하며, cost factor는 12 이상으로 설정하여 brute force 공격에 대한 저항성을 높입니다.

**토큰 도용(S2)**은 XSS 공격이나 localStorage 접근을 통해 인증 토큰을 탈취하는 공격으로, 발생 가능성이 높고 영향도도 치명적입니다. Access Token은 메모리에만 저장하여 페이지 새로고침 시 자동으로 삭제되도록 하며, Refresh Token은 현재 localStorage에 저장하지만 향후 httpOnly 쿠키로 전환할 계획입니다. 이러한 이중 저장 전략은 사용자 경험과 보안 사이의 균형을 맞춥니다.

**세션 하이재킹(S3)**은 네트워크 스니핑을 통한 중간자 공격(MITM)입니다. 발생 가능성은 낮지만 영향도는 높습니다. 완화를 위해 모든 통신에 HTTPS를 강제하고, HSTS(HTTP Strict Transport Security) 헤더를 설정하며, 향후 모바일 앱에서는 인증서 피닝을 구현할 예정입니다.

**GPS 스푸핑(S4)**은 가짜 위치 데이터를 제출하는 공격입니다. 발생 가능성은 중간이지만 영향도는 낮습니다. GPS 정확도 검증, 속도 제한 확인, 경로 이상치 탐지를 통해 완화합니다. 시속 30km를 초과하는 이동이나 100미터 이상의 순간 이동은 자동으로 필터링됩니다.

### Tampering (데이터 무결성 침해)

데이터 변조는 공격자가 저장되거나 전송 중인 데이터를 허가 없이 수정하는 위협입니다. 이는 데이터의 신뢰성을 훼손하고 시스템의 정상 작동을 방해할 수 있습니다.

**운동 데이터 조작(T1)**은 직접 API 호출이나 SQL Injection을 통해 운동 기록을 변조하는 공격입니다. 발생 가능성과 영향도 모두 중간 수준입니다. Zod를 사용한 입력 검증, 파라미터화된 쿼리, 소유권 확인을 통해 완화합니다. 모든 mutation 작업은 반드시 user_id를 확인하여 해당 사용자만 자신의 데이터를 수정할 수 있도록 합니다.

**경로 위조(T2)**는 GPS 좌표를 수정하여 실제와 다른 경로를 기록하는 공격입니다. GPS 검증 규칙, 거리/속도 임계값, 타임스탬프 검증을 통해 완화합니다. 예를 들어, 연속된 두 GPS 포인트 사이의 위도나 경도 차이가 1도를 초과하면 비현실적인 점프로 판단하여 거부합니다.

**토큰 조작(T3)**은 JWT 페이로드를 수정하여 권한을 상승시키려는 공격입니다. 발생 가능성은 낮지만 영향도는 치명적입니다. JWT 서명 검증, 토큰 만료 시간 확인, 정기적인 시크릿 키 교체를 통해 완화합니다. 모든 JWT는 서버 측 시크릿으로 서명되며, 클라이언트에서 수정된 토큰은 서명 불일치로 즉시 거부됩니다.

**데이터베이스 손상(T4)**은 직접 파일 접근이나 SQL Injection을 통한 공격입니다. 파일 권한 설정, 데이터베이스 백업, WAL(Write-Ahead Logging) 모드 활성화를 통해 완화합니다. SQLite 데이터베이스 파일은 애플리케이션 프로세스만 읽고 쓸 수 있도록 권한을 제한합니다.

### Repudiation (부인 방지)

부인은 사용자가 자신이 수행한 작업을 나중에 부인하는 상황입니다. 감사 추적이 없으면 이러한 분쟁을 해결할 수 없습니다.

**운동 제출 부인(R1)**은 사용자가 운동 기록 생성을 부인하는 경우입니다. 발생 가능성은 중간이지만 영향도는 낮습니다. 모든 mutation 작업에 대한 감사 로그와 모든 레코드에 타임스탬프를 기록하여 완화합니다. audit_logs 테이블은 누가, 언제, 무엇을, 어떻게 했는지 완전한 기록을 유지합니다.

**계정 작업 부인(R2)**은 로그인이나 설정 변경 등을 부인하는 경우입니다. 인증 이벤트 로깅(로그인, 로그아웃, 토큰 갱신)을 통해 완화합니다. 각 인증 이벤트는 IP 주소, User-Agent, 타임스탬프와 함께 기록됩니다.

**GPS 추적 부인(R3)**은 위치 추적 동의를 부인하는 경우로, 발생 가능성이 높고 영향도는 중간입니다. 명시적인 GPS 권한 추적과 동의 타임스탬프 기록을 통해 완화합니다. 사용자가 GPS 권한을 승인한 시점과 방법을 데이터베이스에 영구 기록합니다.

### Information Disclosure (정보 노출)

정보 노출은 권한이 없는 사용자가 민감한 정보에 접근하는 위협입니다. 개인정보 보호 관점에서 매우 중요한 영역입니다.

**GPS 데이터 유출(I1)**은 승인되지 않은 API 접근을 통한 위치 정보 노출입니다. 발생 가능성과 영향도 모두 높습니다. 모든 엔드포인트에 인가 적용, 소유자만 접근 가능, GPS 데이터를 공개하지 않음으로 완화합니다. GET /api/workouts 엔드포인트는 자동으로 WHERE user_id = {인증된 사용자 ID} 조건을 추가하여 다른 사용자의 데이터는 절대 반환하지 않습니다.

**자격 증명 노출(I2)**은 로그나 에러 메시지, 소스 코드에 비밀번호나 토큰이 노출되는 경우입니다. 발생 가능성은 중간이지만 영향도는 치명적입니다. bcrypt를 사용한 자격 증명 해싱, 로그에 시크릿을 기록하지 않음, .env 파일로 시크릿 관리를 통해 완화합니다. 모든 민감한 필드는 로깅 전에 자동으로 마스킹됩니다.

**사용자 열거(I3)**는 로그인 에러 메시지를 통해 유효한 이메일 주소를 확인하는 공격입니다. 발생 가능성은 높지만 영향도는 낮습니다. 일반적인 에러 메시지("이메일 또는 비밀번호가 올바르지 않습니다")와 인증 엔드포인트에 대한 속도 제한으로 완화합니다.

**API 키 유출(I4)**은 클라이언트 측 코드나 공개 저장소에 API 키가 노출되는 경우입니다. 환경 변수 사용, .gitignore에 .env 추가, 키 교체 정책 수립으로 완화합니다. VITE_로 시작하는 환경 변수만 클라이언트에 노출되며, 백엔드 시크릿은 절대 클라이언트 번들에 포함되지 않습니다.

### Denial of Service (서비스 거부)

서비스 거부 공격은 정상적인 사용자가 서비스를 이용하지 못하도록 시스템 리소스를 고갈시키는 위협입니다.

**API 플러딩(D1)**은 빠른 요청이나 DDoS를 통해 서버를 과부하 상태로 만드는 공격입니다. 발생 가능성은 중간이고 영향도는 높습니다. express-rate-limit을 사용한 속도 제한과 향후 Cloudflare를 통한 CDN 보호로 완화합니다. 일반 API는 분당 30회, 인증 API는 15분당 5회로 제한합니다.

**데이터베이스 고갈(D2)**은 대용량 경로 업로드를 통한 공격입니다. 페이로드 크기 제한, 경로 포인트 상한(최대 10,000개), 페이지네이션을 통해 완화합니다. 단일 경로가 10,000 GPS 포인트를 초과하면 자동으로 거부됩니다.

**GPS 스팸(D3)**은 추적을 멈추지 않고 계속하는 공격입니다. 클라이언트 측 최대 지속 시간 설정과 24시간 후 자동 중지로 완화합니다. 이는 의도적인 공격뿐만 아니라 사용자가 실수로 추적을 종료하지 않은 경우에도 리소스를 보호합니다.

**토큰 고갈(D4)**은 Refresh Token 스팸을 통한 공격입니다. Refresh Token에 대한 속도 제한과 사용자당 최대 활성 토큰 수 제한으로 완화합니다. 한 사용자는 최대 5개의 동시 세션(5개의 Refresh Token)만 유지할 수 있으며, 새로운 토큰이 생성되면 가장 오래된 것이 자동으로 폐기됩니다.

### Elevation of Privilege (권한 상승)

권한 상승은 일반 사용자가 관리자 권한을 획득하거나 다른 사용자의 데이터에 접근하는 위협입니다.

**다른 사용자 데이터 접근(E1)**은 권한 확인 누락을 악용하는 공격입니다. 발생 가능성과 영향도 모두 치명적입니다. 모든 리소스에 대한 소유권 확인, JWT에 userId 포함, user_id로 필터링을 통해 완화합니다. DELETE /api/workouts/:id 엔드포인트는 먼저 해당 workout의 user_id가 인증된 사용자와 일치하는지 확인한 후에만 삭제를 허용합니다.

**관리자 권한 탈취(E2)**는 SQL Injection이나 JWT 조작을 통한 공격입니다. 발생 가능성은 낮지만 영향도는 치명적입니다. 파라미터화된 쿼리, JWT 서명 검증, 역할 검증을 통해 완화합니다. 현재 MVP에는 관리자 역할이 없지만, 향후 추가 시 role 필드를 JWT에 포함하고 서버 측에서 검증할 것입니다.

**승인되지 않은 삭제(E3)**는 소유권 검증 누락을 악용하는 공격입니다. 발생 가능성은 중간이고 영향도는 높습니다. 삭제/업데이트 전 소유권 이중 확인과 soft delete 구현으로 완화합니다. Soft delete는 데이터를 실제로 삭제하지 않고 deleted_at 플래그를 설정하여 복구 가능성을 유지합니다.

## 인증 및 인가 아키텍처

### JWT 기반 인증 시스템

Good Ruck는 상태 비저장(stateless) JWT 인증을 사용합니다. 이는 확장성이 뛰어나고 모바일 앱과의 호환성이 좋으며 CORS 처리가 간편합니다. 하지만 Access Token을 즉시 무효화할 수 없다는 단점이 있어, 이를 짧은 만료 시간(15분)과 Refresh Token 시스템으로 완화합니다.

**Access Token**은 사용자의 신원을 증명하는 단기 토큰입니다. 15분의 짧은 수명을 가지며, 페이로드에는 userId, email, type('access'), iat(발행 시간), exp(만료 시간)가 포함됩니다. 프론트엔드에서는 React state나 메모리에만 저장되어 페이지 새로고침 시 자동으로 삭제됩니다. 이는 XSS 공격으로 토큰이 탈취되더라도 공격자가 사용할 수 있는 시간을 15분으로 제한합니다.

**Refresh Token**은 새로운 Access Token을 발급받기 위한 장기 토큰입니다. 7일의 수명을 가지며, 페이로드에는 userId, tokenId(고유 식별자), type('refresh'), iat, exp가 포함됩니다. 데이터베이스에는 토큰의 SHA-256 해시만 저장되며, 이는 데이터베이스가 유출되더라도 원본 토큰을 복원할 수 없게 합니다. 사용 시마다 자동으로 교체되는 토큰 로테이션 정책을 적용하여, 한 번 사용된 Refresh Token은 즉시 폐기되고 새로운 토큰이 발급됩니다.

### 인증 흐름의 상세 단계

사용자 등록 시, 클라이언트는 이메일, 비밀번호, 이름을 POST /api/auth/register로 전송합니다. 서버는 Zod 스키마로 입력을 검증하고, bcrypt로 비밀번호를 해시하며(cost factor 12), users 테이블에 새 레코드를 생성한 후 JWT 페어를 생성하여 반환합니다. 클라이언트는 Access Token을 메모리에, Refresh Token을 localStorage에 저장합니다.

로그인 시, 클라이언트는 이메일과 비밀번호를 POST /api/auth/login으로 전송합니다. 서버는 이메일로 사용자를 찾고, bcrypt.compare로 비밀번호를 검증하며, JWT 페어를 생성하고, Refresh Token의 해시를 데이터베이스에 저장한 후 토큰을 반환합니다. 실패한 로그인 시도는 사용자 열거를 방지하기 위해 항상 동일한 일반적인 메시지를 반환합니다.

보호된 리소스 접근 시, 클라이언트는 Authorization: Bearer {accessToken} 헤더와 함께 GET /api/workouts를 요청합니다. authenticateToken 미들웨어가 JWT 서명을 검증하고 만료 시간을 확인하며 userId를 추출합니다. 그런 다음 WHERE user_id = userId 조건으로 운동 기록을 쿼리하여 해당 사용자의 데이터만 반환합니다.

Access Token이 만료되면, 클라이언트는 401 Unauthorized 응답을 받습니다. 에러 코드가 TOKEN_EXPIRED임을 감지하면 자동으로 POST /api/auth/refresh에 Refresh Token을 전송합니다. 서버는 Refresh Token을 검증하고 폐기 여부를 확인한 후, 기존 토큰을 폐기하고 새로운 JWT 페어를 생성하여 반환합니다. 클라이언트는 새 토큰으로 업데이트하고 원래 요청을 재시도합니다. 이 모든 과정은 사용자가 인지하지 못하는 사이에 자동으로 이루어집니다.

로그아웃 시, 클라이언트는 POST /api/auth/logout에 Refresh Token을 전송합니다. 서버는 해당 토큰을 데이터베이스에서 찾아 is_revoked = true, revoked_at = 현재 시간으로 업데이트합니다. 클라이언트는 메모리와 localStorage에서 모든 토큰을 삭제합니다.

### 인가 시스템

인증이 "당신은 누구인가?"를 확인하는 것이라면, 인가는 "당신이 이 작업을 할 수 있는가?"를 확인하는 것입니다. Good Ruck는 리소스 소유권 기반 인가(RBAC의 단순화된 형태)를 사용합니다.

DELETE /api/workouts/:id 요청을 예로 들면, 먼저 authenticateToken 미들웨어가 사용자 신원을 확인합니다. 그런 다음 authorizeOwnership('workout') 미들웨어가 해당 workout의 user_id를 데이터베이스에서 조회하여 인증된 userId와 비교합니다. 일치하면 삭제를 허용하고, 일치하지 않으면 403 Forbidden을 반환합니다. 이는 사용자 A가 사용자 B의 운동 기록을 삭제하는 것을 원천적으로 차단합니다.

## 토큰 관리 정책

### 토큰 저장 전략

Access Token을 localStorage에 저장하는 것은 XSS 공격에 취약합니다. 악의적인 스크립트가 localStorage에 접근하여 토큰을 훔칠 수 있기 때문입니다. 따라서 Access Token은 오직 메모리(React state, 클래스 인스턴스 변수)에만 저장합니다. 이는 페이지 새로고침 시 토큰이 사라진다는 단점이 있지만, Refresh Token으로 자동으로 재발급받을 수 있습니다.

Refresh Token의 가장 안전한 저장 방법은 httpOnly 쿠키입니다. JavaScript에서 접근할 수 없어 XSS 공격으로부터 완전히 보호됩니다. 하지만 쿠키 설정을 위해서는 백엔드와 프론트엔드가 동일한 도메인이거나 CORS 설정이 복잡해집니다. MVP 단계에서는 개발 속도를 위해 localStorage를 사용하되, 다른 보안 통제(input sanitization, CSP)로 XSS 위험을 최소화합니다. 프로덕션 출시 전에 httpOnly 쿠키로 전환할 계획입니다.

백엔드는 Refresh Token의 원본을 저장하지 않고 SHA-256 해시만 저장합니다. 데이터베이스가 유출되더라도 공격자는 해시에서 원본 토큰을 역산할 수 없습니다. 토큰 검증 시에는 클라이언트가 제공한 토큰을 해시하여 데이터베이스의 해시와 비교합니다.

### 토큰 로테이션과 폐기

Refresh Token을 사용할 때마다 새로운 토큰으로 교체하는 자동 로테이션은 토큰 재사용 공격을 방지합니다. 공격자가 오래된 Refresh Token을 훔치더라도 이미 폐기되어 사용할 수 없습니다. 로테이션 프로세스는 다음과 같습니다: 기존 토큰 검증 → 데이터베이스에서 폐기 여부 확인 → 기존 토큰 폐기(is_revoked = true) → 새로운 tokenId 생성 → 새로운 Access Token과 Refresh Token 발급 → 새 Refresh Token 해시를 데이터베이스에 저장 → 클라이언트에 반환.

수동 폐기는 로그아웃 시 실행됩니다. 단일 세션 로그아웃은 현재 Refresh Token만 폐기하고, 전체 세션 로그아웃은 해당 사용자의 모든 Refresh Token을 폐기합니다. 이는 "모든 기기에서 로그아웃" 기능을 구현할 때 유용합니다.

특정 시나리오에서는 모든 토큰을 강제로 폐기해야 합니다. 비밀번호 변경 시에는 보안을 위해 모든 세션을 종료합니다. 의심스러운 활동 감지 시(예: 여러 지역에서 동시 로그인)에도 모든 토큰을 폐기하고 재인증을 요구합니다. 계정이 비활성화되거나 삭제될 때도 모든 토큰을 폐기합니다.

### 토큰 만료 정책

정상 사용 시에는 Access Token이 15분마다 만료되고 Refresh Token으로 자동 갱신됩니다. 사용자는 7일간 활동하지 않으면 Refresh Token도 만료되어 재로그인이 필요합니다. 이는 장기간 방치된 세션의 보안 위험을 줄입니다.

동시 세션은 최대 5개까지 허용합니다. 사용자가 데스크탑, 노트북, 스마트폰 등 여러 기기에서 동시에 로그인할 수 있지만, 6번째 로그인 시 가장 오래된 세션이 자동으로 종료됩니다. 이는 무분별한 토큰 생성을 방지하면서도 실용적인 사용 패턴을 지원합니다.

### 시크릿 관리

JWT_SECRET과 JWT_REFRESH_SECRET은 최소 64자의 무작위 문자열이어야 합니다. Node.js crypto 모듈을 사용하여 생성할 수 있습니다: `node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"`. 두 시크릿은 반드시 다른 값을 사용해야 하며, 소스 코드에 하드코딩하지 않고 환경 변수로 관리합니다.

시크릿 교체 스케줄은 정기 교체와 긴급 교체로 나뉩니다. 정기 교체는 90일마다 실행하며, 이는 장기간 사용된 시크릿의 유출 위험을 줄입니다. 긴급 교체는 시크릿 유출이 의심되는 즉시 실행합니다. 시크릿을 교체하면 모든 기존 토큰이 무효화되어 사용자들이 재로그인해야 하므로, 사전 공지와 함께 사용량이 적은 시간대에 수행해야 합니다.

## CORS와 CSRF 보호

### CORS(Cross-Origin Resource Sharing) 설정

CORS는 브라우저의 동일 출처 정책(Same-Origin Policy)을 완화하여 특정 도메인의 웹 애플리케이션이 다른 도메인의 리소스에 접근할 수 있게 합니다. 하지만 잘못 설정하면 보안 취약점이 될 수 있습니다.

개발 환경에서는 localhost:5173(Vite 개발 서버)과 localhost:3000(대체 포트)을 허용합니다. 프로덕션에서는 실제 프론트엔드 도메인(예: https://goodruck.app, https://www.goodruck.app)만 허용합니다. 와일드카드(*) 사용은 절대 금지되며, 허용된 도메인 목록은 ALLOWED_ORIGINS 환경 변수로 관리합니다.

credentials: true 옵션은 쿠키와 인증 헤더를 포함한 요청을 허용합니다. 이는 JWT Bearer Token을 Authorization 헤더로 전송하는 데 필요합니다. allowedHeaders에는 Content-Type과 Authorization만 명시적으로 허용하여, 예상치 못한 헤더를 통한 공격을 차단합니다.

preflight 요청(OPTIONS 메서드)에 대한 응답은 24시간(maxAge: 86400) 동안 캐시됩니다. 이는 매 요청마다 preflight를 수행하는 오버헤드를 줄이면서도 보안 정책 변경을 하루 안에 반영할 수 있습니다.

### CSRF(Cross-Site Request Forgery) 보호

CSRF는 공격자가 사용자를 속여 의도하지 않은 작업을 실행하게 하는 공격입니다. 예를 들어, 사용자가 로그인한 상태에서 악의적인 사이트를 방문하면, 그 사이트가 사용자 몰래 운동 기록을 삭제하는 요청을 보낼 수 있습니다.

CSRF 토큰 방식은 각 세션마다 고유한 토큰을 생성하고, 상태 변경 요청(POST, PUT, DELETE, PATCH)에 이 토큰을 요구합니다. GET 요청 시 서버는 32바이트의 무작위 토큰을 생성하여 X-CSRF-Token 헤더로 반환하고, 메모리(프로덕션에서는 Redis)에 userId와 함께 저장합니다.

클라이언트는 받은 토큰을 메모리에 저장하고, 이후 모든 상태 변경 요청에 X-CSRF-Token 헤더로 포함시킵니다. 서버는 요청의 토큰과 저장된 토큰을 비교하여 일치하면 요청을 처리하고, 일치하지 않으면 403 Forbidden을 반환합니다. 토큰은 일회용이므로 사용 후 즉시 삭제됩니다.

이 방식은 공격자가 CSRF 토큰을 알 수 없기 때문에 효과적입니다. 토큰은 서버에서 생성되고 응답 헤더로만 전달되므로, 다른 도메인의 JavaScript는 CORS 정책에 의해 이 헤더를 읽을 수 없습니다.

## 속도 제한 및 Rate Limiting

속도 제한은 DoS 공격, brute force 시도, 리소스 남용을 방지하는 핵심 방어 메커니즘입니다. Good Ruck는 엔드포인트 유형에 따라 차등적인 제한을 적용합니다.

### 일반 API 엔드포인트

GET /api/workouts, POST /api/workouts 등 일반 API는 IP 주소당 분당 30회로 제한됩니다. 이는 정상적인 사용 패턴을 허용하면서도 자동화된 스크래핑이나 대량 요청을 차단합니다. 제한을 초과하면 429 Too Many Requests 응답과 함께 Retry-After 헤더를 반환하여 클라이언트가 언제 재시도할 수 있는지 알려줍니다.

### 인증 엔드포인트

POST /api/auth/login과 POST /api/auth/register는 더 엄격하게 제한됩니다. IP 주소당 15분에 5회로 설정하여 brute force 공격을 효과적으로 차단합니다. 한 IP에서 5번의 실패한 로그인 시도 후에는 15분간 추가 시도가 차단되어, 비밀번호를 추측하는 공격을 실질적으로 불가능하게 만듭니다.

### 토큰 갱신 엔드포인트

POST /api/auth/refresh는 사용자당(userId 기준) 분당 10회로 제한됩니다. 이는 정당한 토큰 갱신을 허용하면서도 탈취된 Refresh Token을 악용한 무분별한 Access Token 생성을 방지합니다.

### 환경별 설정

개발 환경에서는 속도 제한을 비활성화하거나 매우 완화하여(예: 분당 1000회) 개발 효율성을 높입니다. 스테이징 환경에서는 프로덕션보다 관대한 제한(예: 분당 100회)을 설정하여 테스트 시나리오를 원활하게 실행합니다. 프로덕션 환경에서는 위에서 설명한 엄격한 제한을 적용합니다.

## 로깅 및 민감 데이터 처리

### 로깅 정책

모든 감사 가능한 이벤트는 반드시 로깅되어야 합니다. 사용자 등록, 로그인, 로그아웃, 비밀번호 변경, 운동 기록 생성/수정/삭제, 토큰 갱신, 토큰 폐기, 실패한 로그인 시도, GPS 권한 승인/거부 등이 포함됩니다. 각 로그 항목은 타임스탬프, 이벤트 유형, 사용자 ID, IP 주소(마스킹됨), User-Agent, 결과(성공/실패), 에러 메시지(있는 경우)를 포함합니다.

절대 로깅해서는 안 되는 정보도 명확히 정의되어 있습니다. 비밀번호(해시된 것도), 전체 JWT 토큰, API 키, 정확한 GPS 좌표, 신용카드 번호, 주민등록번호, 전체 세션 ID는 어떤 경우에도 로그에 기록되지 않습니다.

### PII(Personally Identifiable Information) 마스킹

개인 식별 정보는 로깅 전에 자동으로 마스킹됩니다. 이메일 주소는 로컬 부분의 처음 2글자와 마지막 1글자만 남기고 나머지를 별표로 대체합니다. 예: "user@example.com" → "us***r@example.com". 이는 디버깅에 필요한 최소한의 정보를 유지하면서도 완전한 이메일 주소를 노출하지 않습니다.

GPS 좌표는 개인의 이동 패턴을 추적할 수 있는 매우 민감한 정보입니다. route 배열은 실제 좌표 대신 포인트 개수만 기록합니다: "[523 GPS points]". 개별 좌표가 필요한 경우에는 정수 부분만 남겨 대략적인 지역만 파악 가능하게 합니다: "[37, 126] (rounded)". 이는 서울 지역임은 알 수 있지만 정확한 주소는 알 수 없습니다.

IP 주소는 마지막 옥텟을 제거하여 서브넷 수준으로 마스킹합니다: "192.168.1.105" → "192.168.1.xxx". 이는 일반적인 네트워크 문제 진단에는 충분하지만 개인을 특정할 수는 없습니다.

JWT 토큰은 전체를 로깅하지 않고 처음 4글자와 마지막 4글자만 기록합니다: "eyJhbGc...tU2tIg" → "eyJh...tIg". 이는 토큰 추적에는 유용하지만 실제 인증에는 사용할 수 없습니다.

### 구조화된 로깅

모든 로그는 JSON 형식으로 구조화되어 자동화된 분석과 검색이 가능합니다. 로그 레벨은 DEBUG, INFO, WARN, ERROR로 구분되며, 개발 환경에서는 DEBUG부터, 프로덕션에서는 WARN부터 기록합니다. 이는 로그 볼륨을 관리하면서도 중요한 이벤트는 놓치지 않게 합니다.

500번대 에러는 ERROR 레벨로, 400번대 에러는 WARN 레벨로 로깅됩니다. 이를 통해 로그 집계 시스템에서 심각도별로 필터링하고 알림을 설정할 수 있습니다. 예를 들어, ERROR 레벨 로그가 1분에 10개 이상 발생하면 즉시 관리자에게 알림을 전송합니다.

### 로그 보존 정책

개발 환경의 로그는 로컬 콘솔에만 출력되며 7일간 보관됩니다. 이는 디버깅에는 충분하지만 장기 저장 공간을 절약합니다. 스테이징 환경의 로그는 CloudWatch Logs에 30일간 보관되어 테스트 시나리오 분석에 활용됩니다. 프로덕션 환경의 로그는 CloudWatch Logs에 90일, 장기 보관용으로 S3에 압축하여 저장됩니다. 감사 로그는 컴플라이언스를 위해 1년간 보관됩니다.

## 환경별 보안 설정

### 개발 환경 (Local)

개발 환경은 생산성을 최우선으로 하되, 좋은 보안 습관을 유지합니다. 약한 시크릿 키(예: "dev-secret-key")를 사용하는 것은 허용되지만, 이것이 프로덕션에 배포되지 않도록 .env.example에 명확히 표시합니다. HTTPS는 선택 사항이며 localhost에서는 불필요합니다.

CORS는 모든 localhost 포트를 허용하여 다양한 프론트엔드 설정을 지원합니다. 속도 제한은 비활성화되거나 매우 높게 설정되어 테스트와 디버깅을 방해하지 않습니다. 로그는 상세하게(DEBUG 레벨) 출력되며, 에러 메시지는 전체 스택 트레이스를 포함합니다.

보안 헤더는 완화된 모드로 설정되어 개발 도구의 정상 작동을 허용합니다. 예를 들어, Content Security Policy는 'unsafe-inline'과 'unsafe-eval'을 허용하여 개발 서버의 hot module replacement가 작동하게 합니다.

### 스테이징 환경

스테이징 환경은 프로덕션의 미러이지만 테스트를 위해 약간 완화된 설정을 유지합니다. 강력한 시크릿 키를 사용하되 프로덕션과는 다른 값을 사용합니다. 이는 스테이징 데이터베이스가 유출되더라도 프로덕션에 영향이 없도록 합니다.

HTTPS는 필수이며 실제 도메인(예: staging.goodruck.app)을 사용합니다. CORS는 스테이징 프론트엔드 도메인만 허용합니다. 속도 제한은 활성화되지만 프로덕션보다 관대하게 설정됩니다(예: 분당 100회). 이는 부하 테스트나 자동화된 테스트 시나리오를 실행할 수 있게 합니다.

로그는 INFO 레벨로 설정되어 중요한 이벤트를 추적하면서도 과도한 로그로 인한 비용을 방지합니다. 에러 메시지는 부분적인 상세 정보를 포함하여 문제 진단을 돕습니다. 토큰 만료 시간은 테스트를 위해 짧게 설정될 수 있습니다(예: Access Token 5분).

Sentry와 같은 에러 추적 서비스는 스테이징 환경으로 설정되어 프로덕션 알림과 혼동되지 않도록 합니다. 데이터베이스 백업은 주간 단위로 실행됩니다.

### 프로덕션 환경

프로덕션 환경은 최고 수준의 보안을 적용합니다. JWT 시크릿은 64자 이상의 무작위 문자열이며 90일마다 교체됩니다. 모든 시크릿은 안전한 시크릿 관리 서비스(AWS Secrets Manager, Vercel Environment Variables)에 저장됩니다.

HTTPS는 필수이며 HSTS 헤더를 1년(31,536,000초)의 max-age로 설정합니다. 이는 브라우저가 향후 1년간 이 도메인에 HTTP로 절대 접속하지 않도록 강제합니다. CORS는 프로덕션 도메인만 엄격하게 허용하며, 와일드카드는 사용하지 않습니다.

속도 제한은 매우 엄격하게 설정됩니다. 일반 API는 분당 30회, 인증 API는 15분에 5회로 제한됩니다. 이는 정상적인 사용을 허용하면서도 악의적인 사용을 효과적으로 차단합니다.

로그는 WARN 레벨 이상만 기록하여 중요한 이벤트에 집중하고 저장 비용을 절감합니다. 모든 로그는 PII 마스킹을 거쳐 개인정보 보호 규정을 준수합니다. 에러 메시지는 보안을 위해 일반화되어 시스템 내부 정보를 노출하지 않습니다.

보안 헤더는 최대 강도로 설정됩니다. Content Security Policy는 인라인 스크립트를 차단하고 신뢰할 수 있는 출처만 허용합니다. X-Frame-Options: DENY로 clickjacking을 방지하고, X-Content-Type-Options: nosniff로 MIME 타입 스니핑을 차단하며, Referrer-Policy: strict-origin-when-cross-origin으로 민감한 정보 유출을 방지합니다.

데이터베이스 백업은 매일 자동 실행되며 암호화되어 별도 위치에 저장됩니다. 백업 복원은 정기적으로 테스트되어 실제 재해 시 신속한 복구를 보장합니다. 에러 추적은 Sentry 프로덕션 환경으로 설정되며 민감한 데이터는 삭제된 후 전송됩니다.

### 환경 간 차이점 요약

개발에서 프로덕션으로 갈수록 보안이 점진적으로 강화됩니다. HTTPS는 개발에서는 선택, 스테이징과 프로덕션에서는 필수입니다. HSTS는 개발에서는 비활성화, 스테이징에서는 선택, 프로덕션에서는 필수입니다. CORS는 개발에서는 개방적, 스테이징에서는 제한적, 프로덕션에서는 엄격합니다.

속도 제한은 개발에서는 비활성화, 스테이징에서는 관대, 프로덕션에서는 엄격합니다. 인증 속도 제한은 개발에서는 없음, 스테이징에서는 15분에 10회, 프로덕션에서는 15분에 5회입니다. 토큰 만료는 개발에서는 1시간, 스테이징과 프로덕션에서는 15분입니다.

로깅 레벨은 개발에서는 DEBUG, 스테이징에서는 INFO, 프로덕션에서는 WARN입니다. 에러 상세 정보는 개발에서는 전체, 스테이징에서는 부분, 프로덕션에서는 일반화됩니다. 데이터베이스 백업은 개발에서는 없음, 스테이징에서는 주간, 프로덕션에서는 일간입니다.

## 구현 우선순위

보안 강화는 단계적으로 구현되어야 하며, 가장 중요하고 영향력이 큰 것부터 시작합니다.

### Phase 1: 핵심 보안 (1-2주, 최우선)

JWT 인증 시스템 구현이 최우선입니다. 이는 모든 다른 보안 통제의 기반이 됩니다. bcrypt로 비밀번호 해싱, JWT 발급 및 검증, Refresh Token 로테이션, 소유권 기반 인가를 포함합니다. 이것이 없으면 시스템은 기본적으로 누구나 모든 데이터에 접근할 수 있습니다.

입력 검증은 두 번째 우선순위입니다. Zod를 사용하여 모든 사용자 입력을 프론트엔드와 백엔드 양쪽에서 검증합니다. 이는 SQL Injection, XSS, 데이터 무결성 문제를 방지합니다. CORS 설정은 허용된 도메인만 API에 접근할 수 있도록 합니다.

### Phase 2: 심층 방어 (2-3주)

속도 제한을 추가하여 brute force 공격과 DoS를 방지합니다. CSRF 보호를 구현하여 교차 사이트 요청 위조를 차단합니다. Helmet 미들웨어로 보안 헤더를 설정합니다. 감사 로깅 시스템을 구축하여 모든 중요 이벤트를 추적합니다. PII 마스킹을 적용하여 로그에 민감한 정보가 노출되지 않도록 합니다. 에러 핸들러를 개선하여 프로덕션에서 내부 정보를 노출하지 않습니다.

### Phase 3: 모니터링 및 대응 (3-4주)

Sentry를 통합하여 실시간 에러 추적과 알림을 설정합니다. GitHub Actions로 의존성 스캐닝을 자동화합니다. 보안 사고 대응 계획을 문서화합니다. 의심스러운 활동 감지 로직을 구현합니다(예: 여러 지역에서 동시 로그인). 실패한 로그인 lockout을 구현하여 무차별 대입 공격을 차단합니다. 자동화된 보안 테스트를 CI/CD 파이프라인에 추가합니다.

### Phase 4: 강화 및 고급 기능 (4주 이후)

Refresh Token을 httpOnly 쿠키로 마이그레이션하여 XSS 보호를 강화합니다. Content Security Policy를 추가하여 허용된 콘텐츠 출처만 로드되도록 합니다. 데이터베이스 암호화를 구현합니다(SQLite에서 PostgreSQL로 마이그레이션 시). 다중 인증(MFA)을 추가하여 계정 보안을 한층 강화합니다. 웹 애플리케이션 방화벽(WAF)을 Cloudflare나 AWS WAF로 설정합니다. 침투 테스트를 수행하여 실제 공격 시나리오를 시뮬레이션합니다.

## 컴플라이언스 고려사항

### GDPR (유럽 사용자 대상 시)

GDPR은 EU 시민의 개인정보를 처리하는 모든 조직에 적용됩니다. 접근권(Right to Access)은 사용자가 자신의 모든 데이터를 조회할 수 있는 API를 제공하여 구현합니다. 삭제권(Right to Erasure)은 사용자가 계정과 모든 관련 데이터를 완전히 삭제할 수 있는 기능을 제공합니다. 이동권(Right to Portability)은 사용자 데이터를 JSON 형식으로 내보낼 수 있게 합니다.

동의(Consent)는 GPS 권한 요청 시 명시적으로 확인하고 기록합니다. 데이터 최소화(Data Minimization)는 필요한 GPS 포인트만 수집하고 불필요한 정보는 요청하지 않습니다. 처리 활동 기록(Records of Processing Activities)은 어떤 데이터를 어떤 목적으로 수집하는지 문서화합니다.

### CCPA (캘리포니아 사용자 대상 시)

CCPA는 캘리포니아 거주자의 개인정보를 보호합니다. 요구사항은 GDPR과 유사하지만, 데이터 판매 거부권이 추가됩니다. Good Ruck는 사용자 데이터를 판매하지 않으므로 이 조항은 해당되지 않지만, 개인정보 처리방침에 명시해야 합니다.

## 보안 체크리스트 (배포 전 필수)

배포 전에 다음 항목을 모두 확인해야 합니다. 백엔드: 모든 시크릿이 환경 변수에 있고 코드에 없음, .env 파일이 .gitignore에 있음, JWT 시크릿이 64자 이상, 비밀번호가 bcrypt로 해시됨(cost factor 12 이상), 모든 데이터베이스 쿼리가 파라미터화됨, CORS가 화이트리스트로 설정됨, 속도 제한이 모든 엔드포인트에 활성화됨, 보호된 엔드포인트에 인증 필요, 모든 리소스에 인가 확인, 모든 mutation에 입력 검증, 에러 메시지가 구현 상세를 노출하지 않음, 로그에 민감 데이터 마스킹, 감사 로깅 활성화, HTTPS 강제, 보안 헤더 설정(helmet), 의존성 감사 완료(npm audit), 데이터베이스 백업 예약.

프론트엔드: Access Token이 메모리에만 저장됨, Refresh Token이 localStorage(또는 httpOnly 쿠키)에 있음, 클라이언트 측 코드에 시크릿 없음, API 호출이 HTTPS만 사용, CSRF 토큰이 상태 변경 요청에 포함됨, 사용자 입력이 sanitize됨(XSS 방지), 에러 메시지가 사용자 친화적(스택 트레이스 없음), 토큰 갱신 구현됨, 로그아웃이 모든 토큰 삭제, GPS 권한이 명시적으로 요청됨, 민감 데이터가 콘솔에 로깅되지 않음.

인프라: HTTPS 인증서 유효, HSTS 활성화(프로덕션), 데이터베이스가 공개 접근 불가, 환경 변수가 Railway/Vercel에 설정됨, 모니터링과 알림 설정됨, 로그 보존 정책 구현됨, 백업과 복구 테스트됨, 사고 대응 계획 문서화됨.

## 결론

포괄적인 보안 통제 시스템은 다층 방어(Defense in Depth) 원칙을 따릅니다. 한 계층이 돌파되더라도 다른 계층이 공격을 차단합니다. JWT 인증, 입력 검증, 속도 제한, CORS, CSRF 보호, 감사 로깅, PII 마스킹, 환경별 설정이 모두 협력하여 강력한 보안 체계를 구축합니다.

보안은 일회성 작업이 아니라 지속적인 프로세스입니다. 정기적인 의존성 업데이트, 시크릿 교체, 침투 테스트, 보안 감사를 통해 새로운 위협에 대응해야 합니다. 하지만 가장 중요한 것은 보안 문화를 조직에 내재화하는 것입니다. 모든 개발자가 보안을 "추가 기능"이 아닌 "핵심 요구사항"으로 인식할 때, 진정으로 안전한 애플리케이션이 탄생합니다.
